<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[three.js GPU particles]]></title>
      <url>/2018/07/20/three-js-GPU-particles/</url>
      <content type="html"><![CDATA[<p>three.js的粒子系统没有官方实现，旧版本的<code>THREE.ParticleSystem</code>已经改为<code>THREE.Points</code>了。Examples中有基于<code>DR_DYNAMIC_DRAW</code>的粒子系统实现，但仍需要每帧通过CPU计算生成粒子。另外，three.js还没有支持<code>WebGL2Renderer</code>，所以没有transform feedback。欲实现粒子系统只能另辟蹊径。</p>
<a id="more"></a>
<h1 id="生成粒子索引"><a href="#生成粒子索引" class="headerlink" title="生成粒子索引"></a>生成粒子索引</h1><p>参照官方demo的实现，接收一个<code>BufferGeometry</code>几何，然后为其各个顶点生成顺序的索引。在three.js中只需使用<code>addAttribute</code>，并填入数据，即可填充相应的vbo。</p>
<h1 id="维护粒子状态"><a href="#维护粒子状态" class="headerlink" title="维护粒子状态"></a>维护粒子状态</h1><p>既然要每帧更新粒子的属性，就要使用可用GPU更新的G-Buffer来存储粒子属性。假设粒子属性只有 <code>float</code>,<code>vec2</code>,<code>vec3</code>,<code>vec4</code> 四种类型，则分别对应1-4个分量数。令每个G-Buffer存储四个分量，则所有属性可被pack进数组G-Buffer中，每个粒子映射到G-Buffer中的一个pixel。</p>
<p>通过Double buffering可以维护一个state map。每渲染一帧时，从A中获取上一帧的状态并渲染到B，最后交换AB，这样A中就维护了当前帧的状态。</p>
<p>为粒子在G-Buffer中创建索引，仅需生成粒子唯一的二维坐标即可。这里仅固定width为1024（保证不会超出屏幕分辨率，否则可能会发生culling），模拟二维数组即可。</p>
<p>生成自动维护生命周期和更新粒子状态的着色器。</p>
<h1 id="可编程性"><a href="#可编程性" class="headerlink" title="可编程性"></a>可编程性</h1><p>在main函数中先行提取所有状态（采样贴图），然后调用用户自定义的主函数代理。<br>简单例子如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Wasp.GPUParticleSystem(<span class="keyword">new</span> THREE.BoxBufferGeometry(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>), <span class="keyword">new</span> Wasp.GPUParticleMaterial(&#123;</div><div class="line">	attributes: &#123;</div><div class="line">		pos: &#123;</div><div class="line">			components: <span class="number">4</span>,</div><div class="line">			update: <span class="string">"return pos + vec4(0, 0.2 * delta, 0, 0);"</span>,</div><div class="line">			init: <span class="string">"return vec4(0, 0, 0, 0);"</span></div><div class="line">		&#125;,</div><div class="line">		color: &#123;</div><div class="line">			components: <span class="number">3</span>,</div><div class="line">			update: <span class="string">"return color + vec3(.1, .05, -.1) * delta;"</span>,</div><div class="line">			init: <span class="string">"return vec3(.2, .4, .5);"</span></div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	vertexShader: <span class="string">`</span></div><div class="line"><span class="string">		void main()</span></div><div class="line"><span class="string">		&#123;</span></div><div class="line"><span class="string">			gl_PointSize = 5.;</span></div><div class="line"><span class="string">		&#125;</span></div><div class="line"><span class="string">	`</span>,</div><div class="line">	fragmentShader: <span class="string">`</span></div><div class="line"><span class="string">		void main()</span></div><div class="line"><span class="string">		&#123;</span></div><div class="line"><span class="string">			gl_FragColor = vec4(color, 1);</span></div><div class="line"><span class="string">		&#125;</span></div><div class="line"><span class="string">	`</span></div><div class="line">&#125;));</div><div class="line">scene.add(p);</div></pre></td></tr></table></figure>
<p>可以生成上升的正六面体形粒子系统。</p>
<p>实测在效率允许的情况下（60fps）可以支持到250,000左右的粒子。</p>
<p><img src="/img/2018/7/20/img.png" alt=""></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>整个粒子系统实现比较tricky，但并不复杂。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">"three"</span>;</div><div class="line"><span class="keyword">import</span> &#123; SwappableRenderTarget &#125; <span class="keyword">from</span> <span class="string">"./renderTarget"</span>;</div><div class="line"><span class="keyword">import</span> &#123; PostPass &#125; <span class="keyword">from</span> <span class="string">"./postPass"</span>;</div><div class="line"><span class="keyword">import</span> &#123; extend, substract &#125; <span class="keyword">from</span> <span class="string">"./util"</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">interface</span> GPUParticleMaterialParameters <span class="keyword">extends</span> THREE.ShaderMaterialParameters &#123;</div><div class="line">	attributes?: &#123;</div><div class="line">		[key: <span class="built_in">string</span>]: &#123;</div><div class="line">			components: <span class="built_in">number</span>,</div><div class="line">			update: <span class="built_in">string</span>,</div><div class="line">			init: <span class="built_in">string</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> GPUParticleMaterial <span class="keyword">extends</span> THREE.ShaderMaterial &#123;</div><div class="line">	groups: <span class="built_in">any</span>[] = [];</div><div class="line"></div><div class="line">	<span class="keyword">constructor</span>(<span class="params">parameters?: GPUParticleMaterialParameters</span>) &#123;</div><div class="line">		<span class="keyword">super</span>(GPUParticleMaterial.computeParameters(parameters));</div><div class="line">		<span class="keyword">this</span>.generateAttributes(parameters);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> computeAttributes(parameters?: GPUParticleMaterialParameters) &#123;</div><div class="line">		<span class="keyword">let</span> attrs = extend(</div><div class="line">			&#123; </div><div class="line">			lifetime: &#123;</div><div class="line">				components: <span class="number">1</span>,</div><div class="line">				update: <span class="string">`return lifetime + delta;`</span>,</div><div class="line">				init: <span class="string">`return 0.;`</span></div><div class="line">			&#125;</div><div class="line">			&#125;, </div><div class="line">			parameters.attributes</div><div class="line">		);</div><div class="line">		<span class="keyword">let</span> res = [];</div><div class="line">		<span class="keyword">let</span> attrsVec = [<span class="literal">null</span>, [], [], []];</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> attribute <span class="keyword">in</span> attrs) &#123;</div><div class="line">			<span class="keyword">switch</span> (attrs[attribute].components) &#123;</div><div class="line">			<span class="keyword">case</span> <span class="number">4</span>: res.push([ extend(&#123; name: attribute &#125;, attrs[attribute]) ]); <span class="keyword">break</span>;</div><div class="line">			<span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">case</span> <span class="number">3</span>: attrsVec[attrs[attribute].components].push(extend(&#123; name: attribute &#125;, attrs[attribute])); <span class="keyword">break</span>;</div><div class="line">			<span class="keyword">default</span>: <span class="keyword">throw</span> <span class="string">"invalid components, should be [1,2,3,4]."</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">while</span> (attrsVec[<span class="number">3</span>].length) &#123;</div><div class="line">			<span class="keyword">if</span> (attrsVec[<span class="number">1</span>].length) &#123;</div><div class="line">				res.push([ attrsVec[<span class="number">3</span>].pop(), attrsVec[<span class="number">1</span>].pop() ]);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				res.push([ attrsVec[<span class="number">3</span>].pop() ]);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">while</span> (attrsVec[<span class="number">2</span>].length &gt; <span class="number">1</span>) &#123;</div><div class="line">			res.push([ attrsVec[<span class="number">2</span>].pop(), attrsVec[<span class="number">2</span>].pop() ]);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (attrsVec[<span class="number">2</span>].length) &#123;</div><div class="line">			<span class="keyword">switch</span> (attrsVec[<span class="number">1</span>].length) &#123;</div><div class="line">			<span class="keyword">case</span> <span class="number">0</span>: res.push([ attrsVec[<span class="number">2</span>].pop() ]); <span class="keyword">break</span>;</div><div class="line">			<span class="keyword">case</span> <span class="number">1</span>: res.push([ attrsVec[<span class="number">2</span>].pop(), attrsVec[<span class="number">1</span>].pop() ]); <span class="keyword">break</span>;</div><div class="line">			<span class="keyword">default</span>: res.push([ attrsVec[<span class="number">2</span>].pop(), attrsVec[<span class="number">1</span>].pop(), attrsVec[<span class="number">1</span>].pop() ]); <span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">while</span> (attrsVec[<span class="number">1</span>].length) &#123;</div><div class="line">			<span class="keyword">let</span> e = [];</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i != <span class="number">4</span>; ++i) &#123;</div><div class="line">				<span class="keyword">if</span> (!attrsVec[<span class="number">1</span>].length) <span class="keyword">break</span>;</div><div class="line">				e.push(attrsVec[<span class="number">1</span>].pop());</div><div class="line">			&#125;</div><div class="line">			res.push(e);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> res;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> computeParameters(parameters?: GPUParticleMaterialParameters): THREE.ShaderMaterialParameters &#123;</div><div class="line">		<span class="keyword">let</span> attrs = GPUParticleMaterial.computeAttributes(parameters);</div><div class="line">		<span class="keyword">let</span> params = substract([ <span class="string">"attributes"</span> ], parameters);</div><div class="line">		<span class="keyword">let</span> header = <span class="string">"uniform float nlines;\n"</span>;</div><div class="line">		<span class="keyword">let</span> uniforms = &#123; </div><div class="line">			nlines: &#123; <span class="keyword">type</span>: <span class="string">'f'</span> &#125; </div><div class="line">		&#125;;</div><div class="line">		<span class="keyword">let</span> fv = <span class="string">`\n</span></div><div class="line"><span class="string">			attribute float vertex_id;</span></div><div class="line"><span class="string">			void main()</span></div><div class="line"><span class="string">			&#123;</span></div><div class="line"><span class="string">				vec2 uv = vec2(mod(vertex_id, 1024.)/1024., vertex_id/1024./nlines);`</span>;</div><div class="line">		<span class="keyword">let</span> ff = <span class="string">"\nvoid main() &#123; vec2 uv = gl_FragCoord.xy/vec2(1024, nlines); "</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> group <span class="keyword">in</span> attrs) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">let</span> attr of attrs[group]) &#123;</div><div class="line">				header += [<span class="literal">null</span>,<span class="string">"float"</span>,<span class="string">"vec2"</span>,<span class="string">"vec3"</span>,<span class="string">"vec4"</span>][attr.components] + <span class="string">" "</span> + attr.name + <span class="string">";"</span>;</div><div class="line">			&#125;</div><div class="line">			header += <span class="string">"uniform sampler2D attr"</span> + group + <span class="string">"_map_impl_;\n"</span>;</div><div class="line">			uniforms[<span class="string">"attr"</span> + group + <span class="string">"_map_impl_"</span>] = &#123; <span class="keyword">type</span>: <span class="string">'i'</span> &#125;;</div><div class="line">			<span class="keyword">let</span> getter = <span class="string">"\nvec4 attr"</span> + group + <span class="string">"_val = texture2D(attr"</span> + group + <span class="string">"_map_impl_, uv);"</span>;</div><div class="line">			<span class="keyword">let</span> curr = <span class="number">0</span>;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">let</span> attr of attrs[group]) &#123;</div><div class="line">				<span class="keyword">let</span> comps = <span class="string">"xyzw"</span>.substr(curr, attr.components); curr += attr.components;</div><div class="line">				getter += attr.name + <span class="string">" = attr"</span> + group + <span class="string">"_val."</span> + comps + <span class="string">";"</span>;</div><div class="line">			&#125;</div><div class="line">			fv += getter; ff += getter;</div><div class="line">		&#125;</div><div class="line">		params.uniforms = extend(uniforms, params.uniforms);</div><div class="line">		<span class="keyword">if</span> (!params.vertexShader) params.vertexShader = <span class="string">"\nvoid main() &#123; gl_PointSize = 100.; &#125;\n"</span>;</div><div class="line">		<span class="keyword">if</span> (!params.fragmentShader) params.fragmentShader = <span class="string">"\nvoid main() &#123; gl_FragColor = vec4(1,0,0,1); &#125;\n"</span>;</div><div class="line">		params.vertexShader = header + <span class="string">"\n#define main main_particles_impl_\n"</span> + params.vertexShader + <span class="string">"\n#undef main\n"</span> + fv + <span class="string">`</span></div><div class="line"><span class="string">				vec4 wpos = modelMatrix * vec4(position, 1);</span></div><div class="line"><span class="string">				wpos += vec4(pos.xyz, 0);</span></div><div class="line"><span class="string">				gl_Position = projectionMatrix * viewMatrix * wpos;</span></div><div class="line"><span class="string">				main_particles_impl_();</span></div><div class="line"><span class="string">			&#125;`</span>;</div><div class="line">		params.fragmentShader = header + <span class="string">"\n#define main main_particles_impl_\n"</span> + params.fragmentShader + <span class="string">"\n#undef main\n"</span> + ff + <span class="string">`</span></div><div class="line"><span class="string">				main_particles_impl_(); </span></div><div class="line"><span class="string">			&#125;`</span>;</div><div class="line">		<span class="keyword">return</span> params;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> generateAttributes(parameters?: GPUParticleMaterialParameters) &#123;</div><div class="line">		<span class="keyword">let</span> attrs = GPUParticleMaterial.computeAttributes(parameters);</div><div class="line">		<span class="keyword">let</span> header = <span class="string">`uniform float nlines;\n</span></div><div class="line"><span class="string">			uniform float delta;\n</span></div><div class="line"><span class="string">			uniform float maxLifetime;\n`</span>;</div><div class="line">		<span class="keyword">let</span> uniforms = &#123; </div><div class="line">			nlines: &#123; <span class="keyword">type</span>: <span class="string">'f'</span> &#125;,</div><div class="line">			delta: &#123; <span class="keyword">type</span>: <span class="string">'f'</span> &#125;, </div><div class="line">			maxLifetime: &#123; <span class="keyword">type</span>: <span class="string">'f'</span> &#125;</div><div class="line">		&#125;;</div><div class="line">		<span class="keyword">let</span> footer = <span class="string">"\nvoid main() &#123; vec2 uv = gl_FragCoord.xy/vec2(1024, nlines);"</span>;</div><div class="line"></div><div class="line">		<span class="keyword">let</span> init = [], update = [], funcs = [];</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> group <span class="keyword">in</span> attrs) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">let</span> attr of attrs[group]) &#123;</div><div class="line">				header += [<span class="literal">null</span>,<span class="string">"float"</span>,<span class="string">"vec2"</span>,<span class="string">"vec3"</span>,<span class="string">"vec4"</span>][attr.components] + <span class="string">" "</span> + attr.name + <span class="string">";"</span>;</div><div class="line">			&#125;</div><div class="line">			header += <span class="string">"uniform sampler2D attr"</span> + group + <span class="string">"_map_impl_;\n"</span>;</div><div class="line">			uniforms[<span class="string">"attr"</span> + group + <span class="string">"_map_impl_"</span>] = &#123; <span class="keyword">type</span>: <span class="string">'i'</span> &#125;;</div><div class="line">			footer += <span class="string">"\nvec4 attr"</span> + group + <span class="string">"_val = texture2D(attr"</span> + group + <span class="string">"_map_impl_, uv);"</span>;</div><div class="line">			<span class="keyword">let</span> curr = <span class="number">0</span>;</div><div class="line">			init[group] = update[group] = <span class="string">"return vec4("</span>; funcs[group] = <span class="string">"\n"</span>;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">let</span> attr of attrs[group]) &#123;</div><div class="line">				<span class="keyword">let</span> comps = <span class="string">"xyzw"</span>.substr(curr, attr.components); curr += attr.components;</div><div class="line">				footer += attr.name + <span class="string">" = attr"</span> + group + <span class="string">"_val."</span> + comps + <span class="string">";"</span>;</div><div class="line">				funcs[group] += [<span class="literal">null</span>,<span class="string">"float"</span>,<span class="string">"vec2"</span>,<span class="string">"vec3"</span>,<span class="string">"vec4"</span>][attr.components] + <span class="string">" init_impl_"</span> + attr.name + <span class="string">"() &#123;\n"</span> + attr.init + </div><div class="line">					<span class="string">"\n&#125;\n"</span> + [<span class="literal">null</span>,<span class="string">"float"</span>,<span class="string">"vec2"</span>,<span class="string">"vec3"</span>,<span class="string">"vec4"</span>][attr.components] + <span class="string">" update_impl_"</span> + attr.name + <span class="string">"() &#123;\n"</span> + attr.update + <span class="string">"\n&#125;\n"</span>;</div><div class="line">				init[group] += <span class="string">"init_impl_"</span> + attr.name + <span class="string">"(),"</span>; update[group] += <span class="string">"update_impl_"</span> + attr.name + <span class="string">"(),"</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (curr == <span class="number">4</span>) &#123;</div><div class="line">				init[group] = init[group].substr(<span class="number">0</span>, init[group].length - <span class="number">1</span>) + <span class="string">");"</span>;</div><div class="line">				update[group] = update[group].substr(<span class="number">0</span>, update[group].length - <span class="number">1</span>) + <span class="string">");"</span>;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">let</span> c = []; <span class="keyword">while</span> (curr++ != <span class="number">4</span>) c.push(<span class="number">0</span>);</div><div class="line">				init[group] += c.join(<span class="string">","</span>) + <span class="string">");"</span>; update[group] += c.join(<span class="string">","</span>) + <span class="string">");"</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		footer += <span class="string">"\ngl_FragColor = lifetime &gt; maxLifetime ? init() : update(); &#125;"</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> group <span class="keyword">in</span> attrs) &#123;</div><div class="line">			<span class="keyword">this</span>.groups.push(<span class="keyword">new</span> PostPass(&#123; </div><div class="line">				uniforms: uniforms, </div><div class="line">				fragmentShader: header + funcs[group] + <span class="string">"\nvec4 init() &#123;\n"</span> + init[group] + <span class="string">"\n&#125;\nvec4 update() &#123;\n"</span> + update[group] + <span class="string">"\n&#125;\n"</span> + footer</div><div class="line">			&#125;));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> GPUParticleSystem <span class="keyword">extends</span> THREE.Points &#123;</div><div class="line">	<span class="keyword">private</span> clock = <span class="keyword">new</span> THREE.Clock();</div><div class="line">	<span class="keyword">private</span> nlines: <span class="built_in">number</span>;</div><div class="line">	<span class="keyword">private</span> groups: &#123; value: SwappableRenderTarget; update: PostPass &#125; [] = [];</div><div class="line"></div><div class="line">	<span class="keyword">public</span> maxLifetime: <span class="built_in">number</span> = <span class="number">5</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> computeGeometry(geometry: THREE.BufferGeometry) &#123;</div><div class="line">		<span class="keyword">let</span> geo = geometry.clone();</div><div class="line">		<span class="keyword">let</span> c = []; <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i != geo.attributes.position.count; ++i) c[i] = i;</div><div class="line">		geo.addAttribute(<span class="string">"vertex_id"</span>, <span class="keyword">new</span> THREE.BufferAttribute(<span class="keyword">new</span> <span class="built_in">Float32Array</span>(c), <span class="number">1</span>).setDynamic(<span class="literal">false</span>));</div><div class="line">		<span class="keyword">return</span> geo;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">constructor</span>(<span class="params">geometry: THREE.BufferGeometry, material: GPUParticleMaterial</span>) &#123;</div><div class="line">		<span class="keyword">super</span>(GPUParticleSystem.computeGeometry(geometry), material);</div><div class="line">		<span class="keyword">this</span>.nlines = <span class="built_in">Math</span>.ceil(geometry.attributes.position.count/<span class="number">1024</span>);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> group of material.groups) &#123;</div><div class="line">			<span class="keyword">this</span>.groups.push(&#123; value: <span class="keyword">new</span> SwappableRenderTarget(<span class="number">1024</span>, <span class="keyword">this</span>.nlines, <span class="literal">true</span>), update: group &#125;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	update(renderer: THREE.WebGLRenderer) &#123;</div><div class="line">		<span class="keyword">let</span> source = &#123; </div><div class="line">			nlines: <span class="keyword">this</span>.nlines,</div><div class="line">			delta: <span class="keyword">this</span>.clock.getDelta(),</div><div class="line">			maxLifetime: <span class="keyword">this</span>.maxLifetime</div><div class="line">		&#125;;</div><div class="line">		<span class="keyword">let</span> mat = (&lt;THREE.ShaderMaterial&gt;<span class="keyword">this</span>.material);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> group <span class="keyword">in</span> <span class="keyword">this</span>.groups) &#123;</div><div class="line">			source[<span class="string">"attr"</span> + group + <span class="string">"_map_impl_"</span>] = <span class="keyword">this</span>.groups[group].value.pending.texture;</div><div class="line">			mat.uniforms[<span class="string">"attr"</span> + group + <span class="string">"_map_impl_"</span>].value = <span class="keyword">this</span>.groups[group].value.pending.texture;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> group of <span class="keyword">this</span>.groups) &#123;</div><div class="line">			group.update.render(source, renderer, group.value.current);</div><div class="line">			group.value.swap();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> WebGL </tag>
            
            <tag> three.js </tag>
            
            <tag> particles </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2018.June]]></title>
      <url>/2018/06/26/2018-June/</url>
      <content type="html"><![CDATA[<p>六月的时光悄悄地溜走了。</p>
<p>继续被UB和kano洗脑，被人叫做<strong>妥妥的声控</strong>，感觉很高兴 >w&lt;</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407485894&auto=0&height=66"></iframe>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=26108693&auto=0&height=66"></iframe>

<p>换了新壁纸，并且已经同步到博客背景图上了~</p>
<h1 id="六月的小惊喜"><a href="#六月的小惊喜" class="headerlink" title="六月的小惊喜"></a>六月的小惊喜</h1><ul>
<li>因为图形学认识了更多的人，也有更多的人认识了我。真是很开心！>w&lt;</li>
<li>github首个3+stars的repo（摔</li>
<li>社会实践<strong>安排上了</strong>…</li>
<li>说好的七舍变成五舍了！</li>
</ul>
<h1 id="六月不平凡的日常"><a href="#六月不平凡的日常" class="headerlink" title="六月不平凡的日常"></a>六月不平凡的日常</h1><ul>
<li>重新成为pixiv高级会员！（没错我就是来搜刮图的，才不做什么访问量分析呢）</li>
<li>手机经过长时间的虐待（从一米处跌落），充电口基本凉了。</li>
<li>在电脑屏下发现了sim卡插口，了解到可以改装4g天线加无限流量卡。不过对自己手艺不放心，目前不是很敢拆机…</li>
</ul>
<h1 id="梦幻的结束"><a href="#梦幻的结束" class="headerlink" title="梦幻的结束"></a>梦幻的结束</h1><p>大作业的话，预先准备了将近十分钟的PPT，最后被告知要连着视频展示一起在5分钟内做完。。。和室友分工排练了半天，最终还是截去了很多内容… >_&lt; 不过最终放的视频效果还是可以的（虽然没放声音）。上台演讲的时候，内心完全是一片白空白的，虽然不是很怯场，但是还是莫名感觉有点僵硬。讲话的时候太 <strong>紧张</strong> / <strong>专心</strong> 导致基本没有看到台下同学们的反应。<strong>很想知道他们对我的印象如何。</strong></p>
<blockquote>
<p>希望を失えばまた誰も彼女を見なくなるだろう。<br>路上の小石のように。</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> thoughts </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[镜头模糊]]></title>
      <url>/2018/06/06/%E9%95%9C%E5%A4%B4%E6%A8%A1%E7%B3%8A/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近有一个新目标：实现潜望镜被海浪拍击后的镜头模糊效果。</p>
<p>基本思路是在屏幕上采样一个圆周，记录一下在水面和水下的比例$e$。当$e$有突变时，即可判定镜头与水面有相交，高斯模糊之即可。这样就有两个基本问题：</p>
<ul>
<li>如何高效地从Frame Buffer中获取数据</li>
<li>如何判定一个点在水面以上</li>
</ul>
<a id="more"></a>
<h1 id="Pixel-Retrieve"><a href="#Pixel-Retrieve" class="headerlink" title="Pixel Retrieve"></a>Pixel Retrieve</h1><h2 id="Naive"><a href="#Naive" class="headerlink" title="Naive"></a>Naive</h2><p>首先想到了之前做鼠标检测的方法，直接用<code>glReadPixels</code>读Frame Buffer里的数据，于是我的fps从40掉到了15…</p>
<p>这样做的问题是显而易见的。打开Chrome Dev Panel，发现<code>readPixels</code>等待GPU同步的时间占到每一帧的95%，这显然是无法容忍的。</p>
<h2 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h2><p><img src="/img/2018/6/6/pbo.png" alt=""></p>
<p><a href="">Demo</a>的测试结果如下：</p>
<table>
<thead>
<tr>
<th>Timing results</th>
<th>readPixels (sync)</th>
<th>readPixels (async) + getBufferSubData (sync)</th>
<th>readPixels (async) + getBufferSubDataAsync</th>
</tr>
</thead>
<tbody>
<tr>
<td>time in synchronous picking code</td>
<td>3 ms</td>
<td>3 ms</td>
<td>0 ms</td>
</tr>
<tr>
<td>pick triggered to render complete</td>
<td>~3.5 ms</td>
<td>~3.5 ms</td>
<td>~6.5 ms</td>
</tr>
</tbody>
</table>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> asyncutil &#123;</div><div class="line">	<span class="keyword">static</span> retrieve(N: <span class="built_in">number</span>, <span class="keyword">get</span>: (</div><div class="line">			index: <span class="built_in">number</span>, </div><div class="line">			collect: <span class="function">(<span class="params">data: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">void</span></div><div class="line">		) =&gt; <span class="built_in">void</span>,</div><div class="line">		finish: (</div><div class="line">			data: <span class="built_in">any</span>[]</div><div class="line">		) =&gt; <span class="built_in">void</span></div><div class="line">	) &#123;</div><div class="line">		<span class="keyword">let</span> data = [];</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i != N; ++i) &#123;</div><div class="line">			<span class="keyword">get</span>(i, <span class="function">(<span class="params">x: <span class="built_in">any</span></span>) =&gt;</span> &#123;</div><div class="line">				data[i] = x; --N &gt; <span class="number">0</span> || finish(data);</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> r = <span class="number">300</span>, t = <span class="number">16</span>;</div><div class="line">gl2.readBuffer(gl2.COLOR_ATTACHMENT1);</div><div class="line">asyncutil.retrieve(t, <span class="function">(<span class="params">i: <span class="built_in">number</span>, collect: (<span class="params">data</span>) =&gt; <span class="built_in">void</span></span>) =&gt;</span> &#123;</div><div class="line">	<span class="keyword">let</span> ret = <span class="keyword">new</span> PixelRetriver(<span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="number">1</span>));</div><div class="line">	gl2.readPixels(</div><div class="line">		<span class="number">600</span> + r*<span class="built_in">Math</span>.cos(<span class="number">2</span>*<span class="built_in">Math</span>.PI * i/t), </div><div class="line">		<span class="number">450</span> + r*<span class="built_in">Math</span>.sin(<span class="number">2</span>*<span class="built_in">Math</span>.PI * i/t), </div><div class="line">		<span class="number">1</span>, <span class="number">1</span>, gl2.RED, gl.FLOAT, <span class="number">0</span></div><div class="line">	);</div><div class="line">	ret.getDataAsync(<span class="function">(<span class="params">buffer</span>) =&gt;</span> collect(buffer[<span class="number">0</span>]));</div><div class="line">&#125;, <span class="function">(<span class="params">samples: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</div><div class="line">	<span class="keyword">let</span> s = <span class="number">0</span>; <span class="keyword">for</span> (<span class="keyword">let</span> x of samples) s += x; sample(s / t);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.blurTime &gt; <span class="number">0</span>) &#123;</div><div class="line">	<span class="keyword">let</span> t = <span class="keyword">this</span>.swapBuffer; <span class="keyword">this</span>.swapBuffer = <span class="keyword">this</span>.worldBuffer; <span class="keyword">this</span>.worldBuffer = t;</div><div class="line">	<span class="keyword">this</span>.gaussBlur.setRadius(<span class="number">8</span> * <span class="built_in">Math</span>.sqrt(<span class="keyword">this</span>.blurTime));</div><div class="line">	<span class="keyword">this</span>.gaussBlur.render(<span class="keyword">this</span>.swapBuffer, <span class="keyword">this</span>.worldBuffer);</div><div class="line">	<span class="keyword">this</span>.blurTime -= Renderer.dt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>P.S. <code>WEBGL_get_buffer_sub_data_async</code>属于webgl draft extension，需要在chrome flags里添加<code>--enable-webgl-draft-extensions</code>。</p>
<h1 id="Stencil-Buffer"><a href="#Stencil-Buffer" class="headerlink" title="Stencil Buffer"></a>Stencil Buffer</h1><h1 id="Gallery"><a href="#Gallery" class="headerlink" title="Gallery"></a>Gallery</h1><p><img src="/img/2018/6/6/periscope.jpg" alt=""></p>
<p><img src="/img/2018/6/6/blur.png" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> GL </tag>
            
            <tag> offscreen </tag>
            
            <tag> WebGL </tag>
            
            <tag> pixel-retrieve </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我永远是小妹妹]]></title>
      <url>/2018/05/30/%E6%88%91%E6%B0%B8%E8%BF%9C%E6%98%AF%E5%B0%8F%E5%A6%B9%E5%A6%B9/</url>
      <content type="html"><![CDATA[<p>>w&lt;</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Statistic Ocean Wave Model]]></title>
      <url>/2018/05/18/Statistic-Ocean-Wave-Model/</url>
      <content type="html"><![CDATA[<h1 id="Brief"><a href="#Brief" class="headerlink" title="Brief"></a>Brief</h1><p>NV的流程图介绍该算法简直再清楚不过了：</p>
<p><img src="/img/2018/5/18/nv-brief.jpg" alt=""></p>
<h1 id="Phillips-Spectrum"><a href="#Phillips-Spectrum" class="headerlink" title="Phillips Spectrum"></a>Phillips Spectrum</h1><p>统计模型的示例频谱是Phillips Spectrum：</p>
<p>$$<br>P_h(\vec k) = \left \langle { \left | {\widetilde h}^*(\vec k, t) \right | }^2 \right \rangle<br>$$</p>
<p>在统计学上使用如下模型来模拟Phillips Spectrum：</p>
<p>$$<br>P_h(\vec k) = \frac A { |\vec k|^4} { | \hat k \cdot \hat \omega | }^2 {e^{-\frac 1 { { |\vec k| }^2 L^2}}}<br>$$</p>
<p>生成Phillips Spectrum的像素着色器如下：</p>
<a id="more"></a>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 300 es</span></div><div class="line"></div><div class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</div><div class="line"></div><div class="line"><span class="keyword">in</span> <span class="type">vec2</span> Position0;</div><div class="line"></div><div class="line"><span class="keyword">out</span> <span class="type">vec2</span> Phillips;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="type">float</span> V = <span class="number">1e4</span>;  <span class="comment">// wind speed </span></div><div class="line"><span class="keyword">const</span> <span class="type">vec2</span> u = <span class="built_in">normalize</span>(<span class="type">vec2</span>(<span class="number">1</span>, <span class="number">-1</span>));  <span class="comment">// wind direction</span></div><div class="line"><span class="keyword">const</span> <span class="type">float</span> g = <span class="number">9.8</span>;  <span class="comment">// gravity</span></div><div class="line"><span class="keyword">const</span> <span class="type">float</span> L = V * V / g;  <span class="comment">// parameter</span></div><div class="line"><span class="keyword">const</span> <span class="type">float</span> A = <span class="number">.02</span>;  <span class="comment">// amplitude</span></div><div class="line"></div><div class="line"><span class="type">void</span> main()</div><div class="line">&#123;</div><div class="line">	<span class="type">vec2</span> uv = Position0;</div><div class="line">	<span class="type">float</span> k = <span class="built_in">length</span>(uv);</div><div class="line">	<span class="type">vec2</span> kn = <span class="built_in">normalize</span>(uv);</div><div class="line">	<span class="type">float</span> d = <span class="built_in">dot</span>(kn, u);</div><div class="line">	<span class="type">vec2</span> ph = <span class="type">vec2</span>(A / <span class="built_in">pow</span>(k, <span class="number">4.</span>) * d * d * <span class="built_in">exp</span>(<span class="number">-1.</span>/(k * k * L * L)));</div><div class="line">	Phillips = <span class="built_in">sqrt</span>(ph / <span class="number">2.</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Gaussian-Random-Numbers"><a href="#Gaussian-Random-Numbers" class="headerlink" title="Gaussian Random Numbers"></a>Gaussian Random Numbers</h1><p>在原论文中表述为：</p>
<p>$$<br>\xi(\vec k) = \xi_r + i \xi_i<br>$$</p>
<p>其实部和虚部是两个独立的标准正态分布变量。</p>
<p>后续会写一下这部分。</p>
<h1 id="Initial-Spectrum"><a href="#Initial-Spectrum" class="headerlink" title="Initial Spectrum"></a>Initial Spectrum</h1><p>$$<br>\widetilde H_0(\vec k) = \frac 1 {\sqrt 2} \xi(\vec k) {\sqrt {P_h(\vec k)}}<br>$$</p>
<p>实际生成频谱如图：</p>
<p><img src="/img/2018/5/18/phillips.jpg" alt=""></p>
<p>现有一个疑惑：NV的频谱是不对称的，而我生成的频谱是对称的。单看这个函数表达式感觉没有不对称的理由，不知我理解是不是有偏差。</p>
<h1 id="Displacement-Map"><a href="#Displacement-Map" class="headerlink" title="Displacement Map"></a>Displacement Map</h1><p>Height field：</p>
<p>$$<br>\widetilde H(\vec k, t) = \widetilde H_0(\vec k) e^{i \omega t} + {\widetilde H_0}^*(- \vec k) e^{- i \omega t}<br>$$</p>
<p>即：</p>
<p>$$<br>\widetilde H(\vec k, t) = (cos(\omega t) + i sin(\omega t)) \widetilde H_0(\vec k) + (cos(\omega t) - i sin(\omega t)) {\widetilde H_0}^*(- \vec k)<br>$$</p>
<p>Choppy field：</p>
<p>$$<br>\widetilde D_x(\vec k, t) = i \frac {\vec k.x} { | \vec k | } \widetilde H(\vec k, t)<br>$$</p>
<p>$$<br>\widetilde D_y(\vec k, t) = i \frac {\vec k.y} { | \vec k | } \widetilde H(\vec k, t)<br>$$</p>
<p>计算三个channel的像素着色器如下：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 300 es</span></div><div class="line"></div><div class="line"><span class="meta">#define PI 3.141592654</span></div><div class="line"><span class="meta">#define EPS .00</span></div><div class="line"></div><div class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</div><div class="line"></div><div class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> gSpectrum;</div><div class="line"><span class="keyword">uniform</span> <span class="type">float</span> gTime;</div><div class="line"></div><div class="line"><span class="keyword">in</span> <span class="type">vec2</span> Position0;</div><div class="line"></div><div class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec2</span> H;</div><div class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">out</span> <span class="type">vec2</span> Dx;</div><div class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">out</span> <span class="type">vec2</span> Dy;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="type">float</span> omega = <span class="number">.5</span>;</div><div class="line"></div><div class="line"><span class="type">vec2</span> complexMul(<span class="type">vec2</span> a, <span class="type">vec2</span> b)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> <span class="type">vec2</span>(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">float</span> UVRandom(<span class="type">vec2</span> uv, <span class="type">float</span> salt, <span class="type">float</span> random)</div><div class="line">&#123;</div><div class="line">	uv += <span class="type">vec2</span>(salt, random);</div><div class="line">	<span class="keyword">return</span> <span class="built_in">fract</span>(<span class="built_in">sin</span>(<span class="built_in">dot</span>(uv, <span class="type">vec2</span>(<span class="number">12.9898</span>, <span class="number">78.233</span>))) * <span class="number">43758.5453</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">vec2</span> gaussian(<span class="type">vec2</span> uv, <span class="type">vec2</span> seed)</div><div class="line">&#123;</div><div class="line">	<span class="type">float</span> rand1 = UVRandom(uv, <span class="number">10.612</span>, seed.x);</div><div class="line">	<span class="type">float</span> rand2 = UVRandom(uv, <span class="number">11.899</span>, seed.y);</div><div class="line">	<span class="type">float</span> x = <span class="built_in">sqrt</span>(<span class="number">2.</span> * <span class="built_in">log</span>(rand1 + <span class="number">1.</span>));</div><div class="line">	<span class="type">float</span> y = <span class="number">2.</span> * PI * rand2;</div><div class="line">	<span class="keyword">return</span> x * <span class="type">vec2</span>(<span class="built_in">cos</span>(y), <span class="built_in">sin</span>(y)); </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">void</span> main()</div><div class="line">&#123;</div><div class="line">	<span class="type">float</span> t = gTime;</div><div class="line">	<span class="type">vec2</span> uv = Position0;</div><div class="line">	<span class="type">float</span> k = <span class="built_in">length</span>(uv);</div><div class="line">	<span class="type">float</span> sinv = <span class="built_in">sin</span>(omega * t);</div><div class="line">	<span class="type">float</span> cosv = <span class="built_in">cos</span>(omega * t);</div><div class="line">	<span class="type">vec2</span> tex = uv * <span class="number">.5</span> + <span class="number">.5</span>;</div><div class="line">	<span class="type">vec2</span> seed = <span class="type">vec2</span>(<span class="number">1.</span>, <span class="number">2.</span>) * t * <span class="number">1e-7</span>;</div><div class="line">	<span class="type">vec2</span> h0 = <span class="built_in">texture</span>(gSpectrum, tex).xy;</div><div class="line">	<span class="type">vec2</span> H0 = complexMul(h0, gaussian(tex, seed * <span class="number">.5</span> + <span class="number">1.</span>));</div><div class="line">	<span class="type">vec2</span> h0_conj = <span class="built_in">texture</span>(gSpectrum, -tex).xy * <span class="type">vec2</span>(<span class="number">1</span>, <span class="number">-1</span>);</div><div class="line">	<span class="type">vec2</span> H0_conj = complexMul(h0_conj, gaussian(tex, seed));</div><div class="line">	H = (H0 + H0_conj).xy * cosv + (H0 - H0_conj).yx * <span class="type">vec2</span>(<span class="number">-1</span>, <span class="number">1</span>) * sinv;</div><div class="line">	Dx = (uv.x / k * H).yx * <span class="type">vec2</span>(<span class="number">-1.</span>, <span class="number">1.</span>);</div><div class="line">	Dy = (uv.y / k * H).yx * <span class="type">vec2</span>(<span class="number">-1.</span>, <span class="number">1.</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<p>Height field</p>
<p><img src="/img/2018/5/18/H.jpg" alt=""></p>
<p>Choopy field x</p>
<p><img src="/img/2018/5/18/Dx.jpg" alt=""></p>
<p>Choppy field y</p>
<p><img src="/img/2018/5/18/Dy.jpg" alt=""></p>
<p>基本和NV的结果差不多。</p>
<h1 id="Cooley–Tukey-FFT-GPU-Version"><a href="#Cooley–Tukey-FFT-GPU-Version" class="headerlink" title="Cooley–Tukey FFT - GPU Version"></a>Cooley–Tukey FFT - GPU Version</h1><p>这里我们假定本文的读者都了解并熟悉Cooley-Tuley FFT算法（可以去维基百科简单了解一下），主要说明如何将本算法用普通的GPU渲染管线实现。</p>
<p>普通渲染管线的特点：</p>
<ul>
<li>纯并行，各线程间无法同步</li>
<li>每一个像素无法获取其他像素的任何信息</li>
<li>没有共享内存</li>
</ul>
<p>普通渲染管线输入来源：</p>
<ul>
<li>uniform变量（对于同一个draw call而言是常量）</li>
<li>顶点着色器输出varyings（的线性插值）</li>
<li>纹理（可以有多个channel）</li>
</ul>
<p>普通渲染管线的输出：</p>
<ul>
<li>屏幕</li>
<li>RenderBuffer（开MRT后可以输出多个channel）</li>
<li>纹理（开MRT后可以输出多个channel）</li>
</ul>
<p>要在普通渲染管线上做FFT显然不能采用FFT的递归版本（因为没有共享内存，无法存放中间结果）。观察Cooley-Tukey FFT的流程图，我们发现它的中间结果是分层的。对大小为$N$的序列，中间结果共有$log N+1$层（+1在第一次的bit-reversal copy），每层的大小完全相同（为$N$），每层的寻址方式基本相同（每段分两组寻址，对段长取模即可）。这可以非常自然地使用双纹理交替渲染解决。要对三个channel分别做FFT，只需开启MRT并对接三个channel即可。</p>
<p>二维FFT只要重复做两次一维FFT即可。</p>
<p>渲染流程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// pseudo code</span></div><div class="line">generateFFTData();</div><div class="line">bitReverseCopyHorizontal();</div><div class="line">swapBuffers();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i != N; i *= <span class="number">2</span>) &#123;</div><div class="line">	fftHorizontal();</div><div class="line">	swapBuffers();</div><div class="line">&#125;</div><div class="line">bitReverseCopyVertical();</div><div class="line">swapBuffers();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i != N; i *= <span class="number">2</span>) &#123;</div><div class="line">	fftVertical();</div><div class="line">	swapBuffers();</div><div class="line">&#125;</div><div class="line">generateDisplacement();</div></pre></td></tr></table></figure>
<p>Bit-Reverse Copy</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 300 es</span></div><div class="line"></div><div class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</div><div class="line"></div><div class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> gPrevH;</div><div class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> gPrevDx;</div><div class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> gPrevDy;</div><div class="line"><span class="keyword">uniform</span> <span class="type">float</span> gN;</div><div class="line"></div><div class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec2</span> H;</div><div class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">out</span> <span class="type">vec2</span> Dx;</div><div class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">out</span> <span class="type">vec2</span> Dy;</div><div class="line"></div><div class="line"><span class="type">void</span> main()</div><div class="line">&#123;</div><div class="line">	<span class="type">vec2</span> mn = <span class="built_in">floor</span>(<span class="built_in">gl_FragCoord</span>.xy);</div><div class="line">	<span class="type">float</span> revx = <span class="number">0.</span>;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="type">int</span>(gN); i &gt; <span class="number">1</span>; i /= <span class="number">2</span>)</div><div class="line">	&#123;</div><div class="line">		revx = revx * <span class="number">2.</span> + <span class="built_in">mod</span>(mn.x, <span class="number">2.</span>); mn.x = <span class="built_in">floor</span>(mn.x / <span class="number">2.</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="type">vec2</span> tex = <span class="type">vec2</span>(revx, mn.y) / gN;</div><div class="line">	H = <span class="built_in">texture</span>(gPrevH, tex).rg;</div><div class="line">	Dx = <span class="built_in">texture</span>(gPrevDx, tex).rg;</div><div class="line">	Dy = <span class="built_in">texture</span>(gPrevDy, tex).rg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一次迭代DFT：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 300 es</span></div><div class="line"></div><div class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</div><div class="line"></div><div class="line"><span class="meta">#define PI 3.141592654</span></div><div class="line"></div><div class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> gPrevH;</div><div class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> gPrevDx;</div><div class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> gPrevDy;</div><div class="line"><span class="keyword">uniform</span> <span class="type">float</span> gStep;</div><div class="line"><span class="keyword">uniform</span> <span class="type">float</span> gN;</div><div class="line"></div><div class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec2</span> H;</div><div class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">out</span> <span class="type">vec2</span> Dx;</div><div class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">out</span> <span class="type">vec2</span> Dy;</div><div class="line"></div><div class="line"><span class="type">vec2</span> complexMul(<span class="type">vec2</span> a, <span class="type">vec2</span> b)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> <span class="type">vec2</span>(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">void</span> main()</div><div class="line">&#123;</div><div class="line">	<span class="type">vec2</span> mn = <span class="built_in">floor</span>(<span class="built_in">gl_FragCoord</span>.xy);</div><div class="line">	<span class="type">float</span> k = <span class="built_in">mod</span>(mn.x, gStep * <span class="number">2.</span>);</div><div class="line">	<span class="type">float</span> theta = PI * k / gStep;</div><div class="line">	<span class="type">vec2</span> eo = <span class="type">vec2</span>(mn.x, mn.x + gStep) - <span class="built_in">step</span>(gStep, k) * gStep;</div><div class="line">	<span class="type">vec2</span> epos = <span class="type">vec2</span>(eo.x, mn.y) / gN;</div><div class="line">	<span class="type">vec2</span> opos = <span class="type">vec2</span>(eo.y, mn.y) / gN;</div><div class="line">	<span class="type">vec2</span> term = <span class="type">vec2</span>(<span class="built_in">cos</span>(theta), <span class="built_in">sin</span>(theta));</div><div class="line">	H = <span class="built_in">texture</span>(gPrevH, epos).rg + complexMul(<span class="built_in">texture</span>(gPrevH, opos).rg, term);</div><div class="line">	Dx = <span class="built_in">texture</span>(gPrevDx, epos).rg + complexMul(<span class="built_in">texture</span>(gPrevDx, opos).rg, term);</div><div class="line">	Dy = <span class="built_in">texture</span>(gPrevDy, epos).rg + complexMul(<span class="built_in">texture</span>(gPrevDy, opos).rg, term);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后合并三个channel到displacement map即可：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 300 es</span></div><div class="line"></div><div class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</div><div class="line"></div><div class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> gPrevH;</div><div class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> gPrevDx;</div><div class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> gPrevDy;</div><div class="line"><span class="keyword">uniform</span> <span class="type">float</span> gN;</div><div class="line"></div><div class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec3</span> Displacement;</div><div class="line"></div><div class="line"><span class="type">void</span> main()</div><div class="line">&#123;</div><div class="line">	<span class="type">vec2</span> mn = <span class="built_in">floor</span>(<span class="built_in">gl_FragCoord</span>.xy);</div><div class="line">	<span class="type">float</span> term = <span class="number">1.</span> - <span class="number">2.</span> * <span class="built_in">mod</span>(mn.x + mn.y, <span class="number">2.</span>);</div><div class="line">	<span class="type">vec2</span> tex = mn / gN;</div><div class="line">	<span class="type">float</span> H = term * <span class="built_in">texture</span>(gPrevH, tex).x;</div><div class="line">	<span class="type">float</span> Dx = term * <span class="built_in">texture</span>(gPrevDx, tex).x;</div><div class="line">	<span class="type">float</span> Dy = term * <span class="built_in">texture</span>(gPrevDy, tex).x;</div><div class="line">	Displacement = <span class="type">vec3</span>(Dx, Dy, H) * <span class="number">3e-4</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终生成的displacement map如图：</p>
<p><img src="/img/2018/5/18/displacement.png" alt=""></p>
<p>实际绘制的高度场如图：</p>
<p><img src="/img/2018/5/18/fftwave.png" alt=""></p>
<h1 id="Normal"><a href="#Normal" class="headerlink" title="Normal"></a>Normal</h1><p>直接从displacement map上取样计算法线。</p>
<p><img src="/img/2018/5/18/normal.jpg" alt=""></p>
<p>$$<br>\vec u_1 = \vec u_0 + \vec D_{i+1, j} - \vec D_{i, j}<br>$$<br>$$<br>\vec v_1 = \vec v_0 + \vec D_{i, j+1} - \vec D_{i, j}<br>$$<br>$$<br>\vec N = \vec u_1 \times \vec v_1<br>$$</p>
<p>其中$D$为displacement map，$u_0$ $v_0$为网格大小。</p>
<p>原文中有推导出法线公式，但若按此公式计算需要六趟FFT，有些吃不消。故退而求其次，选择了上述方法。</p>
<p>实际绘制的海面场景如图：</p>
<p><img src="/img/2018/5/18/fftwave2.png" alt=""></p>
<h1 id="Whitecap"><a href="#Whitecap" class="headerlink" title="Whitecap"></a>Whitecap</h1><p>参照论文Real-time animation and rendering of ocean whitecaps中的方法，使用雅各比行列式求出水平运动对水面的撕扯程度：</p>
<p>$$<br>j(\vec p, t) = \left|\begin{array}{cccc}<br>    1 + \sum_i \frac {\partial u(\vec p, t)} {\partial x}  &amp;  \sum_i \frac {\partial u(\vec p, t)} {\partial y} \\<br>    \sum_i \frac {\partial u(\vec p, t)} {\partial y}  &amp; 1 + \sum_i \frac {\partial v(\vec p, t)} {\partial y}<br>\end{array}\right|<br>$$</p>
<p>水面激起白沫的颜色与$j(\vec p t)$假定为线性关系，调参至美观，得到：</p>
<p><img src="/img/2018/5/18/fft-whitecap.jpg" alt=""></p>
<h1 id="Bump-map"><a href="#Bump-map" class="headerlink" title="Bump map"></a>Bump map</h1><p>增加聊胜于无的细节，添加Bump map后的绘制结果：</p>
<p><img src="/img/2018/5/18/fft-bump-whitecap.jpg" alt=""></p>
<p>调整色域、网格大小、修复模型后的绘制结果：</p>
<p><img src="/img/2018/5/18/adjusted.jpg" alt=""></p>
<h1 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h1><p>要扩展到无穷大海面，除了LOD问题外，还要解决采样的周期性问题。NV的slides表明在远处可使用柏林噪声与FFT波形混合，此处用sigmod函数（$f(x) = \frac 1 {1 + e^{-x}}$）做了两次混合。</p>
<p>直接采样的法线，无Filter：</p>
<p><img src="/img/2018/5/18/unfiltered.png" alt=""></p>
<p>两次Sigmod Filter，FFT-&gt;perlin-&gt;$\hat z$：</p>
<p><img src="/img/2018/5/18/sigmod-filter.png" alt=""></p>
<p>最终的绘制结果基本令人满意。</p>
<h1 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h1><ul>
<li><p>texture的filter和wrap方式值得注意。如果设置的filter方式是LINEAR，则FFT采样时会拿到插值后的颜色值，导致FFT结果不正确。在实际海浪采样displacement map时，应选择warp方式为REPEAT，可以省去手动取模的麻烦。</p>
</li>
<li><p>GLSL ES3已经支持所有C语言的运算符（包括位运算）了。</p>
</li>
</ul>
<p><a href="https://github.com/xlnx/bee" target="_blank" rel="external">Github repo</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://people.cs.clemson.edu/~jtessen/papers_files/course_slides2002.pdf" target="_blank" rel="external">Tessondorf - Simulating Ocean Water</a></li>
<li><a href="http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/OceanCS_Slides.pdf" target="_blank" rel="external">Nvidia - OceanCS slides</a></li>
<li><a href="http://www.aholme.co.uk/GPU_FFT/Main.htm" target="_blank" rel="external">GPU FFT</a></li>
<li><a href="http://users.ece.cmu.edu/~franzf/papers/fft-enc11.pdf" target="_blank" rel="external">Different FFT Algorithms</a></li>
<li><a href="http://mc.stanford.edu/cgi-bin/images/7/75/SC08_FFT_on_GPUs.pdf" target="_blank" rel="external">High Performance Discrete Fourier Transforms on Graphics Processors</a></li>
<li><a href="https://dl.acm.org/citation.cfm?id=2407761" target="_blank" rel="external">Real-time animation and rendering of ocean whitecaps</a></li>
<li><a href="http://www.cnblogs.com/hehao98/p/8604163.html" target="_blank" rel="external">使用快速傅里叶变换加速波形计算</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/31670275" target="_blank" rel="external">实时水面模拟与渲染</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> GL </tag>
            
            <tag> WebGL </tag>
            
            <tag> wave-generating </tag>
            
            <tag> FFT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[三天不重构就浑身难受]]></title>
      <url>/2018/05/16/%E4%B8%89%E5%A4%A9%E4%B8%8D%E9%87%8D%E6%9E%84%E5%B0%B1%E6%B5%91%E8%BA%AB%E9%9A%BE%E5%8F%97/</url>
      <content type="html"><![CDATA[<p>我又重构我的小引擎了！</p>
<p>这些技术终于来了，令我觉得相见恨晚。</p>
<p>可能是我太弱智了（</p>
<a id="more"></a>
<h1 id="Floating-Point-Texture"><a href="#Floating-Point-Texture" class="headerlink" title="Floating Point Texture"></a>Floating Point Texture</h1><p><strong>听说你想要一个浮点纹理？我这里有啊！</strong></p>
<p>在<code>webgl1.0</code>中作为扩展的<code>OES_texture_float</code>在<code>webgl2.0</code>中已经转正啦！</p>
<p>在<code>webgl1.0</code>中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gl.getExtension(<span class="string">"OES_texture_float"</span>); <span class="comment">// 使用浮点纹理</span></div><div class="line">gl.getExtension(<span class="string">"OES_texture_float_linear"</span>); <span class="comment">// 使用浮点纹理的linear filter</span></div></pre></td></tr></table></figure></p>
<p>在<code>webgl2.0</code>中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gl2.getExtension(<span class="string">"EXT_color_buffer_float"</span>); <span class="comment">// 渲染到浮点纹理</span></div><div class="line">gl2.getExtension(<span class="string">"OES_texture_float_linear"</span>); <span class="comment">// 使用浮点纹理的linear filter</span></div></pre></td></tr></table></figure></p>
<p>遇到的坑：</p>
<ul>
<li><code>webgl2.0</code>原生支持浮点纹理，但是默认不允许渲染到浮点纹理（虽然大多数浏览器都支持），需要手动require一个扩展<code>EXT_color_buffer_float</code>。</li>
<li>在<code>webgl2.0</code>中，设置浮点纹理的<code>internal format</code>和<code>webgl1.0</code>中的处理办法可能不太相同。如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webgl 2.0</span></div><div class="line">gl2.texImage2D(gl.TEXTRUE_2D, <span class="number">0</span>, gl2.RGBA32F, width, height, <span class="number">0</span>, gl.RGBA, gl.FLOAT, <span class="literal">null</span>); <span class="comment">// 注意 gl2.RGBA32F 和 gl.RGBA，第一个是 internal format</span></div><div class="line"><span class="comment">// webgl 1.0 + OES_texture_float</span></div><div class="line">gl.texImage2D(gl.TEXTRUE_2D, <span class="number">0</span>, gl.RGBA, width, height, <span class="number">0</span>, gl.RGBA, gl.FLOAT, <span class="literal">null</span>); <span class="comment">// 不需要指定 internal format</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://webgl2fundamentals.org/webgl/lessons/webgl-data-textures.html" target="_blank" rel="external">webgl 2.0 纹理数据类型一览</a></li>
</ul>
<p>再也不用编码解码啦！</p>
<h1 id="Multiple-Render-Targets"><a href="#Multiple-Render-Targets" class="headerlink" title="Multiple Render Targets"></a>Multiple Render Targets</h1><p><strong>听说你想一个pass渲染到多个纹理？用MRT吧！</strong></p>
<p>加了高模之后<code>vertex shader</code>需要的时间飞速增长。为了获取多种像素信息（法线、深度、高度、类型等），开多个pass渲染同一个场景显然是不明智的，这个时候<code>MRT</code>就派上用场了。</p>
<p><code>MRT</code>允许你为像素着色器创建多个<code>color attachment</code>，在<code>webgl2.0</code>中，这些channel应为<code>gl2.COLOR_ATTACHMENT0</code>到<code>gl2.COLOR_ATTACHMENT15</code>。</p>
<p>流程：</p>
<ul>
<li>绑定目标纹理到特定的<code>attachment</code></li>
<li>设置当前激活的<code>drawBuffers</code></li>
<li>在像素着色器中输出到<code>attachment</code>相对应的<code>channel</code></li>
<li>恢复原先状态</li>
</ul>
<p>使用<code>MRT</code>合并多个pass示例：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// set channels using gl.framebufferTexture2D</span></div><div class="line"><span class="keyword">this</span>.offscreen.set(gl2.COLOR_ATTACHMENT0, <span class="keyword">this</span>.mainImage);</div><div class="line"><span class="keyword">this</span>.offscreen.set(gl2.COLOR_ATTACHMENT1, <span class="keyword">this</span>.normalDepthImage);</div><div class="line"><span class="keyword">this</span>.offscreen.set(gl2.COLOR_ATTACHMENT2, <span class="keyword">this</span>.typeImage);</div><div class="line"><span class="comment">// specify active channels list, order does not matter</span></div><div class="line">gl2.drawBuffers([</div><div class="line">	gl2.COLOR_ATTACHMENT0, </div><div class="line">	gl2.COLOR_ATTACHMENT1, </div><div class="line">	gl2.COLOR_ATTACHMENT2</div><div class="line">]);</div><div class="line"></div><div class="line">gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</div><div class="line"></div><div class="line"><span class="comment">// render your targets with specified fragment shader.</span></div><div class="line"></div><div class="line">gl2.drawBuffers([</div><div class="line">	gl2.COLOR_ATTACHMENT0</div><div class="line">]);</div></pre></td></tr></table></figure></p>
<p>像素着色器：<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 300 es</span></div><div class="line"></div><div class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</div><div class="line"></div><div class="line"><span class="comment">// location corresponds to attachment id</span></div><div class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> FragColor;</div><div class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">out</span> <span class="type">vec4</span> NormalDepth;</div><div class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">out</span> <span class="type">float</span> Type;</div><div class="line"></div><div class="line"><span class="type">void</span> main()</div><div class="line">&#123;</div><div class="line">	<span class="comment">// process data..</span></div><div class="line"></div><div class="line">	<span class="comment">// output to three channels (corresponds to textures)</span></div><div class="line">	FragColor = <span class="comment">// ...</span></div><div class="line">	NormalDepth = <span class="comment">// ...</span></div><div class="line">	Type = <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Transform-Feedback"><a href="#Transform-Feedback" class="headerlink" title="Transform Feedback"></a>Transform Feedback</h1><p><strong>虽然有人认为这是webgl2.0的一个鸡肋功能（因为没有几何着色器），但我相信这玩意还是能有它自己的用途的。</strong></p>
<p><code>TransformFeedback</code>说白了就是这样一种功能：它可以捕获顶点着色器的输出变量（varyings），并且把它们的值存储到buffer里，这样你就不用在<code>CPU</code>上更新顶点数据并且频繁<code>gl.bufferData</code>了。</p>
<p><code>webgl</code>不能输出到当前的输入buffer，这意味着我们需要使用双buffer。在bufferA中存储所有图元，然后渲染到bufferB，然后swap buffers。因为<code>webgl2.0</code>没有几何着色器，所以输出图元的数量和输入图元的数量应当是一样的，只要保证输出buffer的layout和输入buffer相同，我们就可以轻易地创建一个循环来完成所有的transform工作。</p>
<p>另外，<code>TransformFeedback</code>不能在光栅化前终止（意味着它不能不渲染到一个目标），所以片元着色器依然是必须的，这样可以认为它是需要结合离屏渲染使用的。</p>
<p>我目前想到的使用场景是计算 <strong>物体轨迹</strong>。（拉烟什么的）</p>
<p>后续会对这一部分进行深入研究。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> TBO &#123;</div><div class="line">	<span class="keyword">private</span> handle1;</div><div class="line">	<span class="keyword">private</span> handle0;</div><div class="line"></div><div class="line">	<span class="keyword">constructor</span>(<span class="params"></span>) &#123;</div><div class="line">		<span class="keyword">if</span> (!gl2) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="string">"webgl 2.0 required."</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">this</span>.handle0 = gl2.createBuffer();</div><div class="line">		<span class="keyword">this</span>.handle1 = gl2.createBuffer();</div><div class="line">	&#125;</div><div class="line">	bind() &#123;</div><div class="line">		gl.bindBuffer(gl.ARRAY_BUFFER, <span class="keyword">this</span>.handle0);</div><div class="line">		gl2.bindBufferBase(gl2.TRANSFORM_FEEDBACK_BUFFER, <span class="number">0</span>, <span class="keyword">this</span>.handle1);</div><div class="line">	&#125;</div><div class="line">	unbind() &#123;</div><div class="line">		gl2.bindBufferBase(gl2.TRANSFORM_FEEDBACK_BUFFER, <span class="number">0</span>, <span class="literal">null</span>);</div><div class="line">		gl.bindBuffer(gl.ARRAY_BUFFER, <span class="literal">null</span>);</div><div class="line">	&#125;</div><div class="line">	data(data: <span class="built_in">any</span>[]) &#123;</div><div class="line">		gl.bufferData(gl.ARRAY_BUFFER, <span class="number">4</span> * data.length, gl2.DYNAMIC_COPY);</div><div class="line">		<span class="keyword">this</span>.unbind();</div><div class="line">		<span class="keyword">this</span>.swap();</div><div class="line">		<span class="keyword">this</span>.bind();</div><div class="line">		gl.bufferData(gl.ARRAY_BUFFER, <span class="keyword">new</span> <span class="built_in">Float32Array</span>(data), gl2.DYNAMIC_COPY);</div><div class="line">	&#125;</div><div class="line">	swap() &#123;</div><div class="line">		<span class="keyword">let</span> h = <span class="keyword">this</span>.handle1; <span class="keyword">this</span>.handle1 = <span class="keyword">this</span>.handle0; <span class="keyword">this</span>.handle0 = h;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">get</span> handle(): <span class="built_in">any</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.handle0;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> TransformFeedback &#123;</div><div class="line">	<span class="keyword">public</span> readonly handle: WebGLTransformFeedback;</div><div class="line">	<span class="keyword">private</span> vbo = <span class="keyword">new</span> TBO();</div><div class="line"></div><div class="line">	<span class="keyword">constructor</span>(<span class="params"></span>) &#123;</div><div class="line">		<span class="keyword">if</span> (!gl2) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="string">"webgl 2.0 required."</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">this</span>.handle = gl2.createTransformFeedback();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	bind() &#123;</div><div class="line">		gl2.bindTransformFeedback(gl2.TRANSFORM_FEEDBACK, <span class="keyword">this</span>.handle);</div><div class="line">	&#125;</div><div class="line">	unbind() &#123;</div><div class="line">		gl2.bindTransformFeedback(gl2.TRANSFORM_FEEDBACK, <span class="literal">null</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> TAO &#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">	draw(first: <span class="built_in">number</span> = <span class="literal">undefined</span>, count: <span class="built_in">number</span> = <span class="literal">undefined</span>) &#123;</div><div class="line">		gl2.beginTransformFeedback(gl.POINTS);</div><div class="line">		<span class="keyword">if</span> (first != <span class="literal">undefined</span>) &#123;</div><div class="line">			gl.drawArrays(gl.POINTS, first, count);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			gl.drawArrays(gl.POINTS, <span class="number">0</span>, <span class="keyword">this</span>.numVertices);</div><div class="line">		&#125;</div><div class="line">		gl2.endTransformFeedback();</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，成功让一个点在屏幕上动了起来，并且可以改变颜色。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.khronos.org/registry/webgl/specs/latest/2.0/#3.7.15" target="_blank" rel="external">WebGL 2.0 Specification</a></li>
</ul>
<h1 id="Derivatives"><a href="#Derivatives" class="headerlink" title="Derivatives"></a>Derivatives</h1><p><strong>一个方法，可以让你对插值后的像素着色器输入求关于x和y的偏导数。</strong></p>
<p>实际微分的值是通过获取相邻像素的对应<code>varying</code>并做差分得到的近似值。</p>
<p>想到的实际用途：如果像素着色器输入一个高度场，则可以通过<code>refined point</code>的差分的叉积确定当前像素的法向量：<code>normalize(cross(dx, dy))</code>，这种方法不需要事先对高度场求偏导，至少可以节省一部分顶点着色器的开销（尤其是对于一些<code>non-trival</code>的高度场尤其适用）。</p>
<p>参考：</p>
<ul>
<li><p><a href="https://fgiesen.wordpress.com/2011/07/10/a-trip-through-the-graphics-pipeline-2011-part-8/" target="_blank" rel="external">差分的硬件实现</a></p>
</li>
<li><p><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/dFdx.xhtml" target="_blank" rel="external">Khronos官方介绍</a></p>
</li>
</ul>
<h1 id="Some-other-Techniques"><a href="#Some-other-Techniques" class="headerlink" title="Some other Techniques"></a>Some other Techniques</h1><h2 id="Caustics"><a href="#Caustics" class="headerlink" title="Caustics"></a>Caustics</h2><p>参考一个接近完美的焦散demo，写出了一个很挫的效果。不说了，丢人。</p>
<p>基本想法是用一个mesh来模拟光线的集合，并且把折射前后的两个三角形面积作比，得到当前区域内的平均光照（焦散强度）。</p>
<p>别人的demo：</p>
<p><img src="/img/2018/5/17/caustics0.png" alt=""></p>
<p>我的丢人demo：</p>
<p><img src="/img/2018/5/17/caustics1.jpg" alt=""></p>
<p>参考：</p>
<ul>
<li><p><a href="http://madebyevan.com/webgl-water/" target="_blank" rel="external">在线demo</a></p>
</li>
<li><p><a href="https://medium.com/@evanwallace/rendering-realtime-caustics-in-webgl-2a99a29a0b2c" target="_blank" rel="external">实现原理</a></p>
</li>
</ul>
<h2 id="Fresnel-Blending"><a href="#Fresnel-Blending" class="headerlink" title="Fresnel Blending"></a>Fresnel Blending</h2><p>我可能之前把公式拟合错了，某几个参数是不对的，后来手动调参数拟合了一下，发现基本对上了。</p>
<p><img src="/img/2018/5/17/fitting.png" alt=""></p>
<p>渲染结果：</p>
<p><img src="/img/2018/5/17/render.png" alt=""></p>
<p>参考：</p>
<ul>
<li><p><a href="http://www.slis.tsukuba.ac.jp/~fujisawa.makoto.fu/cgi-bin/wiki/index.php?GLSL%A4%C7%B4%C4%B6%AD%A5%DE%A5%C3%A5%D7%A1%F5%A5%D5%A5%EC%A5%CD%A5%EB%B8%FA%B2%CC#ex_notefoot_1" target="_blank" rel="external">GLSLで環境マップ＆フレネル効果</a></p>
</li>
<li><p><a href="https://www.geogebra.org/graphing" target="_blank" rel="external">Geogebra</a></p>
</li>
</ul>
<h2 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h2><p>根据物体类型降噪，做了一些，现在好多了。</p>
<h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><h2 id="Visual-Studio-Code-Live-Share"><a href="#Visual-Studio-Code-Live-Share" class="headerlink" title="Visual Studio Code Live Share"></a>Visual Studio Code Live Share</h2><p>这功能简直太好用了，强推！</p>
<h2 id="换了新桌面"><a href="#换了新桌面" class="headerlink" title="换了新桌面"></a>换了新桌面</h2><p><img src="/img/2018/5/17/brand.png" alt=""></p>
<h2 id="换了新主题"><a href="#换了新主题" class="headerlink" title="换了新主题"></a>换了新主题</h2><p><img src="/img/2018/5/17/scr1.png" alt=""></p>
<h2 id="没能在5月14日发表-lt"><a href="#没能在5月14日发表-lt" class="headerlink" title="没能在5月14日发表 >_&lt;"></a>没能在5月14日发表 >_&lt;</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/19957067" target="_blank" rel="external">知乎：最值得期待的WebGL 2.0功能</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> GL </tag>
            
            <tag> offscreen </tag>
            
            <tag> WebGL </tag>
            
            <tag> technique </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Screen Space Reflection]]></title>
      <url>/2018/05/03/Screen-Space-Reflection/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在参考SH3的游戏截图的时候，发现船只在水里是有倒影的。</p>
<p><img src="/img/2018/5/3/gwx3-01.jpg" alt=""></p>
<p>个人很喜欢这种效果，于是决定着手开始做。通过查阅相关资料，找到了对应的technique———屏幕空间反射（SSR）。</p>
<a id="more"></a>
<h1 id="Post-process"><a href="#Post-process" class="headerlink" title="Post process"></a>Post process</h1><p>SSR是一种后处理效果。所谓后处理，指的一般是先离屏将场景render到texture里，再用一个独立pass来加工texture。这时原先的buffer就可以通过一个sampler2D中获取。</p>
<p>既然画面和后处理不在同一趟pass，那么后处理时必然会缺失一些原场景中的信息（比如图元类型、顶点、法线、深度、位置等信息）。我们无法在后处理阶段获取任何原场景中的顶点信息（因为没有相应的存储结构），但是对于法线、深度、位置等信息，可以单独开一个pass将其写入texture中，这样在后处理阶段，每个像素对应的相应信息又可通过一个sampler2D来获取。</p>
<h1 id="fragment-attribute-encoding"><a href="#fragment-attribute-encoding" class="headerlink" title="fragment attribute encoding"></a>fragment attribute encoding</h1><p>opengl支持深度纹理、同时支持unsigned char、float、short、int等多种类型的纹理。而webgl 1.0似乎只支持unsigned char纹理，component也只有可怜的RGB、RGB565、RGBA、RGB5A1等几种。。。所以要将顶点信息映射到纹理坐标，首先要对其进行编码。</p>
<h2 id="vec3"><a href="#vec3" class="headerlink" title="vec3"></a>vec3</h2><p>一个三维向量，比如法线、颜色、位置等。</p>
<p>首先将该向量单位化（位置等跟模长有关的不能单位化，所以不能这么存），因为FragColor输出的rgb三个分量会被clamp到$[0, 1]$之间。要保证xyz三个坐标都在$[0, 1]$之间，需要再将单位化后的向量做变换：$X’ = 0.5 X + 0.5$。</p>
<p>解码用$X = 2 X’ - 1$即可。</p>
<h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>一个32bit的浮点数（比如深度）。</p>
<p>通过计算机组成，我们知道IEEE754的32位浮点数形如1-8-23这样，31位是符号位，23-30位是阶码。显然这个浮点数是不能直接通过FragColor的一个分量输出的。如上所述，FragColor会被clamp到$[0, 1]$之间（去掉阶码和符号位），并且被trunc掉尾数的后15位。</p>
<p>这样也很容易想到一个简单的浮点数编码方法（这里只针对单位化的浮点数），即直接去掉阶码和符号位，然后将尾数分段移位，保证每段有8个bit。这样做只需要23/8=3个float就可存储encode一个浮点数。这其实就是把浮点数当成定点数处理了，代码也很好写，只有几行：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// encode</span></div><div class="line"><span class="type">vec4</span> normfloat2vec4(<span class="type">float</span> x)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">const</span> <span class="type">vec4</span> bitShift = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">256.0</span>, <span class="number">256.0</span> * <span class="number">256.0</span>, <span class="number">256.0</span> * <span class="number">256.0</span> * <span class="number">256.0</span>);</div><div class="line">	<span class="keyword">const</span> <span class="type">vec4</span> bitMask = <span class="type">vec4</span>(<span class="number">1.0</span>/<span class="number">256.0</span>, <span class="number">1.0</span>/<span class="number">256.0</span>, <span class="number">1.0</span>/<span class="number">256.0</span>, <span class="number">0.0</span>);</div><div class="line">	<span class="type">vec4</span> rgba = <span class="built_in">fract</span>(x * bitShift);</div><div class="line">	rgba -= rgba.gbaa * bitMask;</div><div class="line">	<span class="keyword">return</span> rgba;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// decode</span></div><div class="line"><span class="type">float</span> vec42normfloat(<span class="type">vec4</span> v)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">const</span> <span class="type">vec4</span> bitShift = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">1.0</span>/<span class="number">256.0</span>, <span class="number">1.0</span>/(<span class="number">256.0</span>*<span class="number">256.0</span>), <span class="number">1.0</span>/(<span class="number">256.0</span>*<span class="number">256.0</span>*<span class="number">256.0</span>));</div><div class="line">	<span class="keyword">return</span> <span class="built_in">dot</span>(v, bitShift);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="compressed-encoding"><a href="#compressed-encoding" class="headerlink" title="compressed encoding"></a>compressed encoding</h2><p>对于一个场景而言，我们可能只需要它的深度信息和法线信息，这时用两个pass渲染场景可能有点浪费，如果场景中物体多了可能会吃不消。这时我们需要一种compressed method来编码发线和深度。</p>
<p>如上所述，如果我们用3个float来编码一个深度信息（透视投影的深度值总是单位化的），这是无损的。如果我们少用一个float，则我们会丢失深度值的最后7个bit，这在某些情况下是可以接受的。同理，我们可以将RGB32的法向量改用RGB565编码，这样会少用掉一个float。将这两个vec2合在一起，我们就可以在一个RGBA32（vec4）的纹理里同时存储法线和深度信息。</p>
<p>pros：</p>
<ul>
<li>占用内存少</li>
<li>少一趟pass（对物体较多的场景比较适合）</li>
</ul>
<p>cons：</p>
<ul>
<li>丢失精度</li>
<li>编码解码稍微复杂点</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// encode</span></div><div class="line"><span class="type">vec2</span> normfloat2vec2(<span class="type">float</span> x)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">const</span> <span class="type">vec2</span> bitShift = <span class="type">vec2</span>(<span class="number">1.0</span>, <span class="number">256.0</span>);</div><div class="line">	<span class="keyword">const</span> <span class="type">vec2</span> bitMask = <span class="type">vec2</span>(<span class="number">1.0</span>/<span class="number">256.0</span>, <span class="number">0.0</span>);</div><div class="line">	<span class="type">vec2</span> rg = <span class="built_in">fract</span>(x * bitShift);</div><div class="line">	rg -= rg.gg * bitMask;</div><div class="line">	<span class="keyword">return</span> rg;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">vec2</span> rgb2rgb565(<span class="type">vec3</span> rgb) &#123;</div><div class="line">	<span class="type">float</span> g1 = rgb.g / <span class="number">32.</span>;</div><div class="line">	<span class="type">float</span> g2 = <span class="built_in">fract</span>(rgb.g * <span class="number">8.</span>);</div><div class="line">	g2 -= <span class="built_in">fract</span>(g2 * <span class="number">8.</span>) / <span class="number">8.</span>;</div><div class="line">	<span class="keyword">return</span> <span class="type">vec2</span>(rgb.r - <span class="built_in">fract</span>(rgb.r * <span class="number">32.</span>) / <span class="number">32.</span> + g1, g2 + rgb.b/<span class="number">8.</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// FragColor = vec4(</span></div><div class="line"><span class="comment">// 	rgb2rgb565(normalize((gV * vec4(Normal0, 0)).xyz) * .5 + .5), </span></div><div class="line"><span class="comment">// 	normfloat2vec2(gl_FragCoord.z)</span></div><div class="line"><span class="comment">// );</span></div><div class="line"></div><div class="line"><span class="comment">// decode</span></div><div class="line"><span class="type">float</span> vec22normfloat(<span class="type">vec2</span> v)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">const</span> <span class="type">vec2</span> bitShift = <span class="type">vec2</span>(<span class="number">1.0</span>, <span class="number">1.0</span>/<span class="number">256.0</span>);</div><div class="line">	<span class="keyword">return</span> <span class="built_in">dot</span>(v, bitShift);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">vec3</span> rgb5652rgb(<span class="type">vec2</span> rgb565)</div><div class="line">&#123;</div><div class="line">	<span class="type">float</span> rr = <span class="built_in">fract</span>(rgb565.r * <span class="number">32.</span>);</div><div class="line">	<span class="type">float</span> bb = <span class="built_in">fract</span>(rgb565.g * <span class="number">8.</span>);</div><div class="line">	<span class="keyword">return</span> <span class="type">vec3</span>(rgb565.r - rr / <span class="number">32.</span>, rr + rgb565.g / <span class="number">8.</span> - bb / <span class="number">64.</span>, bb);</div><div class="line">&#125;</div><div class="line"></div><div class="line">PointInfo decodePoint(<span class="type">vec2</span> uv)</div><div class="line">&#123;</div><div class="line">	PointInfo info;</div><div class="line">	<span class="type">vec4</span> tex = <span class="built_in">texture</span>(gNormalDepth, (uv + <span class="number">1.</span>) * <span class="number">.5</span>);</div><div class="line">	info.normal = rgb5652rgb(tex.rg) * <span class="number">2.</span> - <span class="number">1.</span>;</div><div class="line">	info.depth = vec22normfloat(tex.ba);</div><div class="line">	<span class="keyword">return</span> info;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我没有使用这种方法，原因有二：</p>
<ul>
<li>场景比较空旷</li>
<li>对丢失景深精度比较敏感</li>
</ul>
<h1 id="Screen-Space-Reflection"><a href="#Screen-Space-Reflection" class="headerlink" title="Screen Space Reflection"></a>Screen Space Reflection</h1><h2 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h2><p>下面的所有向量都是在相机空间中的，因为在后处理阶段谈论世界空间一般来说是没有意义的。</p>
<p>为了计算fragment对应的反射向量，我们需要两个向量：</p>
<ul>
<li>入射向量$I$</li>
<li>法向量$N$</li>
</ul>
<p>法向量可以直接从uv对应的sampler2D中获取，这里主要讲入射向量。</p>
<p>入射向量是一个从相机到render point的向量（我们使用反向追踪）。相机在相机空间中的坐标是$[0, 0, 0, 1]^T$，故只需要算出当前render point在相机空间中的坐标即可。</p>
<p>我们知道，render point的uv坐标是在透视空间（屏幕空间）中的。要获取在相机空间中的坐标，乘一个透视矩阵的逆矩阵即可。glsl不具有求逆的功能，需要我们在cpu中先算好逆，再用uniform传进去。事实上，我们完全可以手动算出逆，然后直接hard code进shader里。</p>
<p>linearlizeDepth将透视空间中的z值refine回相机空间z值，事实上这个函数不是数学上正确的，但是可以得到近似的结果。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="type">float</span> linearlizeDepth(<span class="type">vec2</span> uv)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> - gP[<span class="number">3</span>].z / (<span class="number">1.</span> - vec42normfloat(<span class="built_in">texture</span>(gDepth, (uv + <span class="number">1.</span>) * <span class="number">.5</span>)));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">vec3</span> refinePoint(<span class="type">vec2</span> uv)</div><div class="line">&#123;</div><div class="line">	<span class="type">float</span> z = linearlizeDepth(uv);</div><div class="line">	<span class="keyword">return</span> <span class="type">vec3</span>(uv.x / gP[<span class="number">0</span>].x, uv.y / gP[<span class="number">1</span>].y, <span class="number">-1.</span>) * z;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了入射向量和法向量，我们就可以算出相机空间中的反射向量$R$。</p>
<h2 id="Raymarching"><a href="#Raymarching" class="headerlink" title="Raymarching"></a>Raymarching</h2><p>朴素的Raymarching想法是这样的：先refine当前position$P$，每次迭代加上一个$step \times R$，然后每次把新的$P$用透视矩阵投影到屏幕上，然后取depth。这样就要在每个iteration里做一次projection，耗费大概会比较大。</p>
<h2 id="Depth-based-2D-Raymarching"><a href="#Depth-based-2D-Raymarching" class="headerlink" title="Depth based 2D Raymarching"></a>Depth based 2D Raymarching</h2><p>我们可以先把反射向量$R$做一次投影，算出它在屏幕空间的uv，然后只需要每次迭代加uv，并refine depth即可。</p>
<p>这种方法要注意的一个点是：屏幕空间不是一个线性空间（屏幕空间在乘了透视矩阵之后还将w分量归一化了，这里就非线性了）。对于点$[x, y, z, 1]^T$，在线性空间$W$中的对应点为$W \times [x, y, z, 1]^T$，所以对应的向量$[x, y, z, 0]^T$在$W$中的对应向量为$W \times [x, y, z, 0]^T$（$W \times [x_2, y_2, z_2, 1]^T - W \times [x_1, y_1, z_1, 1]^T = W \times [x, y, z, 0]^T$）。在透视空间$P$中，点$[x, y, z, 1]^T$对应的点为$W \times [x, y, z, 1]^T / z$，相应的向量$V = [x, y, z, 0]^T$也就不满足$V’ = P \times V / z$。实际上变换后的向量应该跟它的出发点有关，即得到屏幕空间中正确向量的做法是$V’ = P \times (O + V) / z_2 - P \times O / z_1$。</p>
<p>同样，透视空间中的深度也是非线性的，需要先做一遍refinement。</p>
<h2 id="Enhancement-Binary-search"><a href="#Enhancement-Binary-search" class="headerlink" title="Enhancement - Binary search"></a>Enhancement - Binary search</h2><p>使用Binary search能保证用较少的迭代次数快速收敛到比较精确的深度。大概想法是在开始设置一个较大的步长，每次检测到碰撞（深度差值flip）后撤回上一步搜索并且减半步长。实际证明这种方法是非常有效的。</p>
<h2 id="noise"><a href="#noise" class="headerlink" title="noise"></a>noise</h2><p>现在没做，以后再说。</p>
<p>会先看看Perlin noise等，之后再做。</p>
<h1 id="Gallery"><a href="#Gallery" class="headerlink" title="Gallery"></a>Gallery</h1><p>相机空间法向量</p>
<p><img src="/img/2018/5/3/refined-camera-space-normal.png" alt="相机空间法向量"></p>
<p>透视空间深度</p>
<p><img src="/img/2018/5/3/refined-depth.png" alt="透视空间深度"></p>
<p>相机空间坐标</p>
<p><img src="/img/2018/5/3/refined-camera-space-point.png" alt="相机空间坐标"></p>
<p>565法向量16深度纹理</p>
<p><img src="/img/2018/5/3/norm565-dep16.png" alt="565法向量16深度"></p>
<p>屏幕空间反射</p>
<p><img src="/img/2018/5/3/screen-space-reflected.png" alt="屏幕空间反射"></p>
<p>屏幕空间反射+水波</p>
<p><img src="/img/2018/5/3/screen-space-reflected2.jpg" alt="屏幕空间反射+水波"></p>
<h1 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h1><p>请自行想象一下debug shader是一种多么痛苦的过程。</p>
]]></content>
      
        
        <tags>
            
            <tag> GL </tag>
            
            <tag> water-rendering </tag>
            
            <tag> WebGL </tag>
            
            <tag> raymarching </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2018.Apr]]></title>
      <url>/2018/05/01/2018-Apr/</url>
      <content type="html"><![CDATA[<h1 id="最近"><a href="#最近" class="headerlink" title="最近"></a>最近</h1><p><strong>我对rendering的痴迷程度达到了吃饭、上厕所和睡觉的时候都无法阻止去想的程度了。</strong></p>
<h2 id="CG换题和重构"><a href="#CG换题和重构" class="headerlink" title="CG换题和重构"></a>CG换题和重构</h2><p>前一个拟题（巫师棋）被我废弃了。理由是对照老师的给分点，发现偏差比较大。最终题目定在了silent hunter的复刻版。</p>
<p>这可能是我最喜欢的一个题目，虽然当时还我不确定能不能做好，但是总要有一个破釜沉舟的决策出现。</p>
<p>对原C++17引擎用Tyoescript重构，只花了4天时间就超过了原有效果。</p>
<p>现在看了一眼整体的技术路线，除了烟雾、火光的粒子系统实现（可能需要抛弃所有webgl 1.0浏览器的支持）之外，所有技术路线都已经确定并可以实施。</p>
<p>实现了很多原有技术：</p>
<ul>
<li>Phong Lighting（已废弃，后续版本在渲染夜晚时可能加上）</li>
<li>Shadow Cubemap（PCF不知道为什么崩了，现在去掉了阴影）</li>
<li>Gerstner Wave（后续会被基于统计学模型的FFT替换）</li>
<li>LOD（不一样的照搬，减少了DrawCall次数）</li>
</ul>
<p>加入了很多新技术（很多是基于render screen square的）：</p>
<ul>
<li>Offscreen Rendering（Basis）</li>
<li>Dynamic Ambient Cubemap（这个简直太棒了）</li>
<li>Observer Viewport</li>
<li>Fresnel Effect（目前处于崩溃状态）</li>
<li>Defered Image</li>
</ul>
<p>主要是重构了offscreen和texture的逻辑，使用起来达到了一种惊人的方便程度。终于可以放心地实现各种technique啦！</p>
<p>后续马上要做的：</p>
<ul>
<li>Ubisoft Model Refinement</li>
<li>FFT</li>
<li>Raymarch based SSR（Screen Space Reflection）</li>
</ul>
<p>下面是我的喃喃自语..</p>
<a id="more"></a>
<h2 id="数据库上半学期结束"><a href="#数据库上半学期结束" class="headerlink" title="数据库上半学期结束"></a>数据库上半学期结束</h2><p>期中大程结束了。这裸js糊出来的工程我都不愿意多看一眼，交给助教验收的时候居然说我做的很好，WTF。</p>
<p>果然人类都是视觉动物啊。</p>
<h2 id="动漫绘画结束"><a href="#动漫绘画结束" class="headerlink" title="动漫绘画结束"></a>动漫绘画结束</h2><p>希望老师不会因为我不是树莓的就拉低我的分（</p>
<p>课程本身我还是很满意的，很休闲，最后几节课还能上板，很开心（</p>
<h2 id="计组"><a href="#计组" class="headerlink" title="计组"></a>计组</h2><p>计组有种要吃大礼包的感觉，平时得多加把劲了（</p>
<h2 id="职规"><a href="#职规" class="headerlink" title="职规"></a>职规</h2><p>这鬼课程终于没了（</p>
<h2 id="面向信息技术的沟通技巧"><a href="#面向信息技术的沟通技巧" class="headerlink" title="面向信息技术的沟通技巧"></a>面向信息技术的沟通技巧</h2><p>我喜欢上陈越的课！</p>
<h1 id="夏学期突击计划，启动！"><a href="#夏学期突击计划，启动！" class="headerlink" title="夏学期突击计划，启动！"></a>夏学期突击计划，启动！</h1><p>整个周三和周二晚上都空出来了，一大块连续时间最适合做些莫名其妙的研究了..</p>
<h1 id="ASC"><a href="#ASC" class="headerlink" title="ASC"></a>ASC</h1><p>过了ASC之后可能会考虑退队，因为我已经不想再做一个既没有贡献又没有很大兴趣可言的队内寄生虫了。</p>
<p>然而我还是想和大家一起开心地玩啊>_&lt;</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>四月的时间（我醒着的时间）有三分之一在研究rendering，有三分之一在写代码，有三分之一在上课和写作业。娱乐时间基本没有，OSU和炉石都很少上了。总之，我个人还是很满意的（虽然还是亏欠了一些债务）。</p>
<p>希望自己能加把劲，继续努力。</p>
]]></content>
      
        
        <tags>
            
            <tag> thoughts </tag>
            
            <tag> GL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于迭代器失效]]></title>
      <url>/2018/04/08/%E5%85%B3%E4%BA%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88/</url>
      <content type="html"><![CDATA[<p><code>::std::move</code>容器并不会使迭代器失效，除非move改变了allocator。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_wrapper</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;    m_list;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myList &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = myList.begin();</div><div class="line"></div><div class="line">    list_wrapper wrappedList;</div><div class="line">    wrappedList.m_list = <span class="built_in">std</span>::move(myList);</div><div class="line"></div><div class="line">    <span class="comment">// iter is still valid and points to the begin of m_list</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://stackoverflow.com/questions/41384793/does-stdmove-invalidate-iterators" target="_blank" rel="external">StackOverflow大法好</a></p>
]]></content>
      
        
        <tags>
            
            <tag> STL </tag>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Object Picking]]></title>
      <url>/2018/03/30/Object-Picking/</url>
      <content type="html"><![CDATA[<p>终于忙完了一摞奇怪的事，回来研究Object Picking了…</p>
<p>目前了解到的Object Picking方法有以下两种：</p>
<ul>
<li>Ray Picking</li>
<li>FBO Picking</li>
</ul>
<p>顾名思义，Ray Picking按射线方向对各物体判交，因为之前没有做几何检测（甚至AABB包围盒都没做），所以先pass掉了（SRTP对接VR手柄时这个是一定要做的）。另外一种方法（FBO Picking）比较有趣，此处做下记录。</p>
<h1 id="FBO-Picking"><a href="#FBO-Picking" class="headerlink" title="FBO Picking"></a>FBO Picking</h1><a id="more"></a>
<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><p>为场景中的物体各选一个不同的颜色，做一趟离线渲染，取出帧缓存鼠标位置的颜色，即获得Picking Object.</p>
<h2 id="Modified"><a href="#Modified" class="headerlink" title="Modified"></a>Modified</h2><p>Color Buffer只用一个分量，把物体编号cast进去即可。</p>
<h2 id="Improved"><a href="#Improved" class="headerlink" title="Improved"></a>Improved</h2><p>创建一个鼠标指向的摄像机，缩小视角，渲染到一个1x1的矩阵即可。</p>
<h1 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h1><p>glRenderbufferStorage的第二个参数要指定位宽和类型，把GL_R32F写成GL_RED，调了一年。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p><a href="https://github.com/xlnx/bee" target="_blank" rel="external">code</a></p>
<p>接下来准备研究如何让给物体添加外轮廓，大概是stencil buffer + normal displacement这样。</p>
<p>使用X1C是一种享受。</p>
]]></content>
      
        
        <tags>
            
            <tag> GL </tag>
            
            <tag> offscreen </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2018.March]]></title>
      <url>/2018/03/28/2018-March/</url>
      <content type="html"><![CDATA[<p>最近心情很好，一直很开心。</p>
<a id="more"></a>
<p>逐渐感觉发生什么事都无所谓了。</p>
<p>都是我的错。</p>
<p>另外：换了X1C 2018。</p>
]]></content>
      
        
        <tags>
            
            <tag> thoughts </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[简要记录一下最近的情况]]></title>
      <url>/2018/03/18/%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E6%9C%80%E8%BF%91%E7%9A%84%E6%83%85%E5%86%B5/</url>
      <content type="html"><![CDATA[<p>简要记录一下最近的情况吧。</p>
<p>开学阶段总是比较杂乱> &lt;</p>
<a id="more"></a>
<h1 id="SRTP定题"><a href="#SRTP定题" class="headerlink" title="SRTP定题"></a>SRTP定题</h1><p>基于VR的多人合作3D建模系统。</p>
<p>有点头大，主要是精度问题。不过考虑到双手柄且手柄输入比鼠标多一个维度，感觉还具有一定的可实施性。<br>服务器的问题倒是好办。</p>
<p>基本打算是这学期把VR部分基本搞出来，下学期上计网的同时去弄服务器，可以方便一些。</p>
<h1 id="修改了Phong光照模型"><a href="#修改了Phong光照模型" class="headerlink" title="修改了Phong光照模型"></a>修改了Phong光照模型</h1><p>emm，其实很早就实现了，但是刚刚参考了Assimp和3Dmax光照部分相关参数，对原Phong模型进行了一些修正（原模型主要参考<a href="ogldev.co.uk">ogldev</a>）。<br>例如原Phong模型对specular的处理是：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Light = Ambient + Shadow * (Specular + Diffuse);</div><div class="line">FragColor = Color * Light;</div></pre></td></tr></table></figure>
<p>这样当物体为纯黑表面时<code>FragColor</code>总为零。实际上，镜面反射和物体本身的颜色是无关的，将光照模型修改如下：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Light = Ambient + Shadow * Diffuse;</div><div class="line">LightSpec = Shadow * Specular;</div><div class="line">FragColor = Color * Light + LightSpec;</div></pre></td></tr></table></figure>
<p>用上述方法渲染得到的结果如下：<br><img src="/img/2018/3/19/phong.png" alt=""></p>
<h1 id="近期TODO"><a href="#近期TODO" class="headerlink" title="近期TODO"></a>近期TODO</h1><ul>
<li>SRTP草案，PPT</li>
<li>SQTP相关事宜，外加两篇文章</li>
<li>ADS：准备抢接下来的Project</li>
<li>计组：MIPS汇编器/反汇编器</li>
<li>实现抗锯齿，在Compute Shader中计算鼠标位置，实现骨骼动画。</li>
<li>SQL：期中大程，期末大程，权衡用QT还是Java（</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> thoughts </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[水面LOD相关]]></title>
      <url>/2018/02/27/%E6%B0%B4%E9%9D%A2LOD%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<p>看了<a href="http://www.gdcvault.com/play/1015517/Water-Technology-of" target="_blank" rel="external">GDC上Naughty Dog关于水体渲染的介绍</a>，准备写点LOD相关内容。</p>
<h1 id="Level-of-Details"><a href="#Level-of-Details" class="headerlink" title="Level of Details"></a>Level of Details</h1><p>由于透视，近处的物体要比远处物体的细节丰富很多。在实时渲染时，如果一视同仁地渲染远处和近处的物体，不仅浪费了远处物体的细节，还降低了渲染速度，因此产生了LOD技术。</p>
<a id="more"></a>
<h1 id="水面网格LOD"><a href="#水面网格LOD" class="headerlink" title="水面网格LOD"></a>水面网格LOD</h1><p>以摄像机为中心生成一张正方形环状网格图，从内环到外环网眼大小逐渐增大，如图：</p>
<p><img src="/img/2018/2/27/LOD.jpg" alt=""></p>
<p>若要渲染尺寸为$W$，最小网格宽度为$e$的水面，不使用LOD的空间复杂度是$O(\frac {W^2} {e^2})$，使用LOD的空间复杂度为$O(\frac {W {W_0} + {W_0}^2 } {e^2})$，其中$W_0$为一级精细度渲染尺寸。</p>
<h1 id="边界修复"><a href="#边界修复" class="headerlink" title="边界修复"></a>边界修复</h1><p>由于矩形环相接处边缘点没有啮合，这样渲染时会有缝隙，需要手动将边缘点与下一层对应点连接。如图：</p>
<p><img src="/img/2018/2/27/fix.jpg" alt=""></p>
<p>此处渲染可用<code>GL_TRIANGLE_FAN</code>。</p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>如果远处波浪频率过大，会较严重地受到受网眼大小影响，在摄像机移动时在环面相交处会有闪烁现象。解决方案是忽略远处的高频波浪以及使用法线贴图。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul>
<li>背景换成了暖色&gt;w&lt;</li>
<li>要开学了，又是令人激动的新学期呢（</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> GL </tag>
            
            <tag> LOD </tag>
            
            <tag> mesh-generating </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于Gerstner Wave的水面shader]]></title>
      <url>/2018/02/22/%E5%9F%BA%E4%BA%8EGerstner-Wave%E7%9A%84%E6%B0%B4%E9%9D%A2shader/</url>
      <content type="html"><![CDATA[<h1 id="Gerstner-Wave"><a href="#Gerstner-Wave" class="headerlink" title="Gerstner Wave"></a>Gerstner Wave</h1><p>$$<br>\left\{<br>\begin{aligned}<br>\begin{array}{rl}<br>x &amp;= p - QDA\sin(D \cdot p - \omega t)\\<br>y &amp;= A\cos(D \cdot p - \omega t)<br>\end{array}<br>\end{aligned}<br>\right.<br>$$</p>
<a id="more"></a>
<h1 id="参数曲面的法向量"><a href="#参数曲面的法向量" class="headerlink" title="参数曲面的法向量"></a>参数曲面的法向量</h1><p>$$<br>\left\{<br>\begin{aligned}<br>\begin{array}{rl}<br>x &amp;= x(u, v)\\<br>y &amp;= y(u, v)\\<br>z &amp;= z(u, v)<br>\end{array}<br>\end{aligned}<br>\right.<br>$$<br>固定$v$，得到关于$u$的曲线，在$p = (u, v)$处的切向量为<br>$$<br>t_u = \{\frac {\partial x} {\partial u}, \frac {\partial y} {\partial u}, \frac {\partial z} {\partial u} \}<br>$$<br>固定$u$，得到关于$v$的曲线，在$p = (u, v)$处的切向量为<br>$$<br>t_v = \{\frac {\partial x} {\partial v}, \frac {\partial y} {\partial v}, \frac {\partial z} {\partial v} \}<br>$$<br>曲面的法向量$n_p$同时与$t_u$，$t_v$垂直，故曲面在点$p = (u, v)$处的法向量为<br>$$<br>t_u \times t_v = \left|\begin{array}{cccc}<br>    i &amp;    j    &amp; k \\<br>    x_u &amp;  y_u  &amp; z_u\\<br>    x_v &amp;  y_v  &amp; z_v<br>\end{array}\right|<br>$$</p>
<h1 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h1><p>$$<br>\left\{<br>\begin{aligned}<br>\begin{array}{rl}<br>x &amp;= u - QD_xA\sin\alpha\\<br>y &amp;= v - QD_yA\sin\alpha\\<br>z &amp;= A\cos\alpha<br>\end{array}<br>\end{aligned}<br>\right.<br>$$<br>其中<br>$$<br>\alpha = fD \cdot p - \omega t = f(uD_x + vD_y) - \omega t<br>$$</p>
<p>$$<br>\left\{<br>\begin{aligned}<br>\begin{array}{rl}<br>t_u &amp;= \{1 - fQD_x^2A\cos\alpha, -fQD_xD_yA\cos\alpha, -fAD_x\sin\alpha\}\\<br>t_v &amp;= \{- fQD_xD_yA\cos\alpha, 1 - fQD_y^2A\cos\alpha, -fAD_y\sin\alpha\}<br>\end{array}<br>\end{aligned}<br>\right.<br>$$<br>法向量为<br>$$<br>n_p = \{fAD_x\sin\alpha, fAD_y\sin\alpha, 1 - fQA\cos\alpha\}<br>$$</p>
<p>对于$n$个Gerstner Wave叠加的情况，顶点为：<br>$$<br>\left\{<br>\begin{aligned}<br>\begin{array}{rl}<br>x &amp;= u - \sum Q{D_x}A\sin\alpha\\<br>y &amp;= v - \sum Q{D_y}A\sin\alpha\\<br>z &amp;= \sum A\cos\alpha<br>\end{array}<br>\end{aligned}<br>\right.<br>$$<br>法向量为：<br>$$<br>\left\{<br>\begin{aligned}<br>\begin{array}{rl}<br>x &amp;= \sum fAD_x\sin\alpha\\<br>y &amp;= \sum fAD_y\sin\alpha\\<br>z &amp;= 1 - \sum fQA\cos\alpha\<br>\end{array}<br>\end{aligned}<br>\right.<br>$$</p>
<h1 id="Vertex-Shader"><a href="#Vertex-Shader" class="headerlink" title="Vertex Shader"></a>Vertex Shader</h1><figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#version 330 core</span></div><div class="line"></div><div class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> Position;</div><div class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec3</span> Normal;</div><div class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">5</span>) <span class="keyword">in</span> <span class="type">vec2</span> TexCoord;</div><div class="line"></div><div class="line"><span class="keyword">out</span> <span class="type">vec2</span> TexCoord0;</div><div class="line"><span class="keyword">out</span> <span class="type">vec3</span> Normal0;</div><div class="line"><span class="keyword">out</span> <span class="type">vec3</span> WorldPos0;</div><div class="line"><span class="keyword">out</span> <span class="type">vec3</span> Offset0;</div><div class="line"><span class="comment">// out vec4 Color0;</span></div><div class="line"></div><div class="line"><span class="meta">#define MAX_GERSTNER_WAVE_COUNT 128</span></div><div class="line"></div><div class="line">struct GerstnerWave &#123;</div><div class="line">	<span class="type">float</span> Steepness;</div><div class="line">	<span class="type">float</span> Amplitude;</div><div class="line">	<span class="type">float</span> Frequency;</div><div class="line">	<span class="type">float</span> Speed;</div><div class="line">	<span class="type">vec2</span> Direction;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">uniform</span> GerstnerWave gGerstnerWave[MAX_GERSTNER_WAVE_COUNT];</div><div class="line"><span class="keyword">uniform</span> <span class="type">int</span> gGerstnerWaveCount;</div><div class="line"><span class="keyword">uniform</span> <span class="type">float</span> gTime;</div><div class="line"></div><div class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> gWVP;</div><div class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> gWorld;</div><div class="line"></div><div class="line"><span class="type">void</span> GerstnerLevelOne(<span class="type">vec3</span> vertex, <span class="keyword">out</span> <span class="type">vec3</span> <span class="keyword">offset</span>, <span class="keyword">out</span> <span class="type">vec3</span> normal)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">offset</span> = <span class="type">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">	normal = <span class="type">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; gGerstnerWaveCount; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="type">float</span> dp = <span class="built_in">dot</span>(vertex.xy, gGerstnerWave[i].Direction.xy);</div><div class="line">		<span class="type">float</span> p = gGerstnerWave[i].Frequency * dp - gGerstnerWave[i].Speed * gTime;</div><div class="line">		<span class="type">float</span> Acos = gGerstnerWave[i].Amplitude * <span class="built_in">cos</span>(p);</div><div class="line">		<span class="type">float</span> Asin = gGerstnerWave[i].Amplitude * <span class="built_in">sin</span>(p);</div><div class="line">		<span class="keyword">offset</span>.x -= gGerstnerWave[i].Steepness * </div><div class="line">			gGerstnerWave[i].Direction.x * Asin;</div><div class="line">		<span class="keyword">offset</span>.y -= gGerstnerWave[i].Steepness * </div><div class="line">			gGerstnerWave[i].Direction.y * Asin;</div><div class="line">		<span class="keyword">offset</span>.z += Acos;</div><div class="line"></div><div class="line">		normal.x += gGerstnerWave[i].Frequency *</div><div class="line">			gGerstnerWave[i].Direction.x * Asin;</div><div class="line">		normal.y += gGerstnerWave[i].Frequency * </div><div class="line">			gGerstnerWave[i].Direction.y * Asin;</div><div class="line">		normal.z -= gGerstnerWave[i].Frequency *</div><div class="line">			gGerstnerWave[i].Steepness * Acos;</div><div class="line">	&#125;</div><div class="line">	normal = <span class="built_in">normalize</span>(normal);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">void</span> main()</div><div class="line">&#123;</div><div class="line">	<span class="type">vec3</span> <span class="keyword">offset</span>;</div><div class="line">	<span class="type">vec3</span> normal;</div><div class="line">	<span class="type">vec3</span> Position0 = Position;</div><div class="line">	GerstnerLevelOne(Position0, <span class="keyword">offset</span>, normal);</div><div class="line">	Position0 += <span class="keyword">offset</span>;</div><div class="line">	<span class="built_in">gl_Position</span> = gWVP * <span class="type">vec4</span>(Position0, <span class="number">1.0</span>);</div><div class="line">	<span class="comment">// TexCoord0 = TexCoord;</span></div><div class="line">	<span class="keyword">if</span> (normal.z &lt; <span class="number">0</span>)</div><div class="line">		normal.z = -normal.z;</div><div class="line">	Normal0 = (gWorld * <span class="type">vec4</span>(normal, <span class="number">0.0</span>)).xyz;</div><div class="line">	WorldPos0 = (gWorld * <span class="type">vec4</span>(Position0, <span class="number">1.0</span>)).xyz;</div><div class="line">	<span class="comment">// Color0 = vec4(clamp(Position0, 0.0, 1.0), 1.0);</span></div><div class="line">	<span class="comment">// gl_Position = gWVP * vec4(Position, 1.0);</span></div><div class="line">	Offset0 = <span class="keyword">offset</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="/img/2018/2/22/water.jpg" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> GL </tag>
            
            <tag> water-rendering </tag>
            
            <tag> wave-generating </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL学习]]></title>
      <url>/2018/02/16/OpenGL%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h1><p>最近为学习下学期的计图做准备。刚刚读完<a href="http://blog.csdn.net/column/details/13062.html" target="_blank" rel="external">《一步步学习OpenGL3.3+》</a>，并阅读了<a href="https://github.com/zurl/ElfGE" target="_blank" rel="external">Zurl先辈的游戏引擎ElfGE</a>源码。在学习过程中将OpenGL进行了基本封装，加上Assimp，摄像机和灯光，构建了一个基本的3D绘制框架<a href="https://github.com/xlnx/bee" target="_blank" rel="external">bee</a>，并实现了一些可以渲染3D模型的实例。</p>
<p>渲染结果看上去是这样的：<br><a id="more"></a><br><img src="/img/2018/2/16/teapot1.png" alt=""><br><img src="/img/2018/2/16/teapot2.png" alt=""><br><img src="/img/2018/2/16/teapot3.jpg" alt=""><br><img src="/img/2018/2/16/bismark1.png" alt=""><br><img src="/img/2018/2/16/bismark2.jpg" alt=""></p>
<p>期间又学习了一些3D建模工具的使用（3Dmax，3DBuilder for win10），bismark是我在<a href="https://baike.baidu.com/item/%E7%8C%8E%E6%9D%80%E6%BD%9C%E8%88%AA3/4169794?fromtitle=%E7%8C%8E%E6%9D%80%E6%BD%9C%E8%88%AA%E2%85%A2&amp;fromid=11320980" target="_blank" rel="external">SH3</a>的模型数据里偷的（</p>
<p>基本的图形学知识已经有了，接下来准备学习水面渲染。</p>
<h1 id="水面渲染初步"><a href="#水面渲染初步" class="headerlink" title="水面渲染初步"></a>水面渲染初步</h1><p>目前水面渲染一般采用如下方法：</p>
<ul>
<li>将水面视为一张矩形2D网格，并将每个矩形网眼分为上下两个三角形，确定网格各点的2D坐标。</li>
<li>对每帧，计算网格各点的高度坐标和顶点法线。</li>
</ul>
<p>其中步骤1可直接在初始化过程计算，步骤二则需要大量计算，一般使用vertex shader完成。</p>
<h2 id="正弦波叠加"><a href="#正弦波叠加" class="headerlink" title="正弦波叠加"></a>正弦波叠加</h2><p>略去…</p>
<h2 id="平静水面的法向量模拟法"><a href="#平静水面的法向量模拟法" class="headerlink" title="平静水面的法向量模拟法"></a>平静水面的法向量模拟法</h2><p>对于平静的水面，我们可以只计算顶点的法向量，而将z值置为0。这样水面只有在计算反射光时会显现出波纹，计算量较小。</p>
<h2 id="Gerstner-Wave"><a href="#Gerstner-Wave" class="headerlink" title="Gerstner Wave"></a>Gerstner Wave</h2><p>在计算机图形学中，Gerstener Wave是一种应用广泛的水面模拟方法。</p>
<h3 id="离线波形生成"><a href="#离线波形生成" class="headerlink" title="离线波形生成"></a>离线波形生成</h3><p>对于给定参数方程的模拟波形，可以离线生成一个周期的波形，运行时通过顶点的位置来确定相位，查表获取z值。由于Gersterner Wave具有对称性，只需生成半个周期的波形即可。</p>
<p>采样例图如下，红点表示采样点：<br><img src="/img/2018/2/16/sample.jpg" alt=""><br>任意顶点的相位会落在某两个采样点<code>l, l+1</code>之间，其z值可以通过对相应区间进行线性内插得到。</p>
<p>实现Gerstner Wave的任意相位的z值计算：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">float</span> <span class="title">gerstnerZ</span><span class="params">(<span class="keyword">float</span> w, <span class="keyword">float</span> h, <span class="keyword">float</span> x)</span> <span class="keyword">const</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="keyword">const</span> <span class="keyword">auto</span> T = <span class="number">2</span> * sampleX[sampleCount - <span class="number">1</span>];</div><div class="line">	x = fmodf(x * T / w, T);</div><div class="line">	<span class="keyword">if</span> (x &gt; T / <span class="number">2</span>)</div><div class="line">	&#123;</div><div class="line">		x = T - x;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// search for xpos section</span></div><div class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = sampleCount, m = (l + r) &gt;&gt; <span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span> (r - l &gt; <span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (sampleX[m] &gt; x)</div><div class="line">		&#123;</div><div class="line">			r = m;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span></div><div class="line">		&#123;</div><div class="line">			l = m;</div><div class="line">		&#125;</div><div class="line">		m = (l + r) &gt;&gt; <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// linear interpolation</span></div><div class="line">	<span class="keyword">return</span> h * (sampleY[l] + (x - sampleX[l]) </div><div class="line">		/ (sampleX[r] - sampleX[l]) * (sampleY[r] - sampleY[l]));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="自适应细节的离线波形生成"><a href="#自适应细节的离线波形生成" class="headerlink" title="自适应细节的离线波形生成"></a>自适应细节的离线波形生成</h3><p>在离线生成波形时，我们希望在波形较尖锐处插入更多的采样点，而在波形较少处插入较少的采样点（如上图）。假设要插入采样点的个数为<code>n</code>，则采样区间的个数为<code>m=n-1</code>，使用等差数列自适应采样区间长度，有下式：<br>$$<br>S = \sum_{i=0}^{m-1} l_i = \pi<br>$$<br><code>Q=0</code>时，Gerstner Wave为正弦波，令采样区间均匀，即：<br>$$<br>l_0 = \frac S m, d = 0<br>$$<br><code>Q=1</code>时，假设最短的采样区间的长度为采样区间平均长度的1/3，有下式：<br>$$<br>l_0 = \frac S {3m}, d = \frac {4\pi} {3m(m-1)}<br>$$<br>对<code>Q</code>进行线性内插，得：<br>$$<br>l_0(Q) = l_0(1) Q + l_0(0) (1-Q) = \frac {\pi} m (1 - \frac 2 3 Q)<br>$$<br>$$<br>d(Q) = d(1) Q + d(0) (1-Q) = \frac {4\pi} {3m(m-1)} Q<br>$$</p>
<p>上述算法的C++实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSample</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="comment">// sharpness-precision auto adaption </span></div><div class="line">	<span class="keyword">float</span> start = M_PI * (<span class="number">1</span> - <span class="number">2.f</span> / <span class="number">3.f</span> * fSharpness) / (sampleCount - <span class="number">1</span>);</div><div class="line">	<span class="keyword">float</span> det = <span class="number">4</span> * M_PI * fSharpness / (<span class="number">3.f</span> * (sampleCount - <span class="number">1</span>) * (sampleCount - <span class="number">2</span>));</div><div class="line">	<span class="keyword">auto</span> alpha = M_PI;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = sampleCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</div><div class="line">	&#123;</div><div class="line">		sampleX[i] = alpha - fSharpness * sinf(alpha - M_PI);</div><div class="line">		sampleY[i] = cosf(alpha - M_PI);</div><div class="line">		alpha -= start; start += det;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="法向量生成"><a href="#法向量生成" class="headerlink" title="法向量生成"></a>法向量生成</h3><p>顶点的法向量可以通过相邻四个面的法向量取平均值获得，如图：<br><img src="/img/2018/2/16/normal.jpg" alt=""><br>$$<br>\overrightarrow n = normalize(\overrightarrow {v_0} \times \overrightarrow {v_1} +<br>    \overrightarrow {v_1} \times \overrightarrow {v_2} +<br>    \overrightarrow {v_2} \times \overrightarrow {v_3} +<br>    \overrightarrow {v_3} \times \overrightarrow {v_0})<br>$$</p>
<p>也可对参数方程微分获得。</p>
<h3 id="GPU版本"><a href="#GPU版本" class="headerlink" title="GPU版本"></a>GPU版本</h3><p>上述实现只包含CPU版本，因为生成法向量需要旁边顶点的坐标。后续考虑会用微分+线性内插的方法生成法向量，这样就可以用vertex shader实现上述计算。</p>
<h2 id="其他水面波形模拟方法"><a href="#其他水面波形模拟方法" class="headerlink" title="其他水面波形模拟方法"></a>其他水面波形模拟方法</h2><p><a href="https://www.shadertoy.com/view/Ms2SD1" target="_blank" rel="external">shaderToy - Seascape</a>，渲染效果非常棒，最近也有拜读这份代码的打算。</p>
<p>…</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>继承树：<br><img src="/img/2018/2/16/inheritTree.jpg" alt=""></p>
<p><a href="https://github.com/xlnx/bee" target="_blank" rel="external">bee</a></p>
<p>我要变成小妹妹了&gt;w&lt;</p>
]]></content>
      
        
        <tags>
            
            <tag> GL </tag>
            
            <tag> water-rendering </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2017.Nov]]></title>
      <url>/2017/11/29/2017-Nov/</url>
      <content type="html"><![CDATA[<h1 id="Nov"><a href="#Nov" class="headerlink" title="Nov"></a>Nov</h1><p>降温啦&gt;_&lt;</p>
<a id="more"></a>
<h2 id="月初"><a href="#月初" class="headerlink" title="月初"></a>月初</h2><p>用JS+遗传算法写了一个<a href="//koishi.top/applets/graph-demon">无向图的自动画图</a>脚本，<del>现阶段处于放置play状态</del></p>
<h2 id="双十一"><a href="#双十一" class="headerlink" title="双十一"></a>双十一</h2><p>买了一块茶轴的CrazyBoard<del>我的第一块机械键盘</del>（-500），手感一般，打字的时候有种泡水里的感觉。。。不过确实有提升手速，打串稳了不少，ACC略有提升。<br>《并行程序设计导论》  </p>
<h2 id="考试周"><a href="#考试周" class="headerlink" title="考试周"></a>考试周</h2><p>pass</p>
<h2 id="考试周结束后"><a href="#考试周结束后" class="headerlink" title="考试周结束后"></a>考试周结束后</h2><p>画了很多，但是都不很满意，没放在p站上。线条和色彩还都控制得不是很到位<br>对着《并行程序设计导论》把MPI的接口熟悉了一下</p>
<h2 id="几天前"><a href="#几天前" class="headerlink" title="几天前"></a>几天前</h2><p>tampermonkey初使用<br>冬学期第一周，物联网课和学弟同班，成功组队</p>
<h2 id="今天"><a href="#今天" class="headerlink" title="今天"></a>今天</h2><p>把数逻的VGA接口写完了，准备尽早弄完大作业，好腾出期末时间<del>复习</del></p>
<h2 id="osu"><a href="#osu" class="headerlink" title="osu!"></a>osu!</h2><p>很久没刷pp了，神清气爽</p>
<h1 id="近期计划"><a href="#近期计划" class="headerlink" title="近期计划"></a>近期计划</h1><ul>
<li>数逻大作业</li>
<li>看体系结构，编译优化</li>
<li>玩玩Intel Parallel Studio</li>
<li>学习一下C#的反射，看osu!framework的源代码</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> thoughts </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[blog加载速度优化]]></title>
      <url>/2017/11/09/blog%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>自开通blog后收到了数不胜数的 <b>网页加载过慢</b> 的投诉…<br>自己试了试，在关掉cache的情况下达到了非常不能忍的加载速度，大概加载完要50多秒…<br>在某些不加载完就不显示页面的浏览器上更让人抓狂（咳咳<br>由于以上原因决定试着做点优化…  </p>
<a id="more"></a>
<h1 id="背景图"><a href="#背景图" class="headerlink" title="背景图"></a>背景图</h1><p>其实背景图有点花。为了不喧宾夺主，已经被我打了个高斯模糊，但是裸加载的时候是从上到下加载的，看上去非常傻..  </p>
<p>缩图到了十分之一大小，感觉加载速度变快了<br><b>哈哈.jpg</b><br><del>反正都高斯模糊了</del>  </p>
<p>P.S.<br><del>发现Edge不支持blur？！</del><br>在论坛上看到这个bug在新版本中修复了，但是微软似乎还没给我推送这个更新…<br>哈哈…</p>
<h1 id="蜜汁脚本"><a href="#蜜汁脚本" class="headerlink" title="蜜汁脚本"></a>蜜汁脚本</h1><p>缩了图后加载速度从50s降到了大概35s，感觉没什么太大效果。用hexo s试了一下本地加载，发现一样慢…<br>用chrome的waterfall检查，结果大概这样：<br><img src="/img/2017/11/9/waterfall.jpg"><br>emmmm…<br>发现果然有迷之脚本<b>Valine.min.js</b>，产生了巨长的等待时间。<br>仔细检查一下Request，结果发现源脚本被302重定向了..<br>经过<del>没过大脑的</del>思考，我把源文件手动download并link了一下，大功告成！blog加载速度飞一样的提升..  </p>
<p>回头想想发现我好像没有引用Valine..<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Valine.</span></div><div class="line"><span class="comment"># You can get your appid and appkey from https://leancloud.cn</span></div><div class="line"><span class="comment"># more info please open https://valine.js.org</span></div><div class="line"><span class="attr">valine:</span></div><div class="line"><span class="attr">  enable:</span> <span class="literal">false</span></div><div class="line">  <span class="comment"># ...</span></div></pre></td></tr></table></figure></p>
<p>确实没有。<br>这就很有趣了…  </p>
<p>在目录里搜索了一下valine，发现<b>valine.swig</b>里有个bug：<br><del>好像没有swig高亮，用html将就一下了…</del><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn1.lncld.net/static/js/3.0.4/av-min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//unpkg.com/valine/dist/Valine.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">&#123;% if theme.valine.enable and theme.valine.appid and theme.valine.appkey %&#125;</div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="comment">// ....</span></span></div><div class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure></p>
<h2 id="问号-jpg"><a href="#问号-jpg" class="headerlink" title="问号.jpg"></a>问号.jpg</h2><p>这个引用居然在if外面？？  </p>
<p>最终修改：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;% if theme.valine.enable and theme.valine.appid and theme.valine.appkey %&#125;</div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn1.lncld.net/static/js/3.0.4/av-min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//unpkg.com/valine/dist/Valine.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="comment">// ....</span></span></div><div class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure></p>
<h1 id="CDN加速！"><a href="#CDN加速！" class="headerlink" title="CDN加速！"></a>CDN加速！</h1><p>试用了一下<a href="http://www.bootcdn.cn/" target="_blank" rel="external">BootCDN</a>，感觉效果很不错..  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>无cache秒开..  </p>
]]></content>
      
        
        <tags>
            
            <tag> thoughts </tag>
            
            <tag> blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[koishi.top!]]></title>
      <url>/2017/11/05/koishi-top/</url>
      <content type="html"><![CDATA[<p>打算给github page弄个域名，于是去万网逛了一圈发现了这个…<br><br><a href="http://www.koishi.top" target="_blank" rel="external">恋恋世界第一</a><br><br>未来十年也要做萝莉控啊QwQ</p>
]]></content>
      
        
        <tags>
            
            <tag> thoughts </tag>
            
            <tag> hello-world </tag>
            
            <tag> blog </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <url>/404/index.html</url>
      <content type="html"><![CDATA[<p><img src="404.png"></p>
]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>/about/about.css</url>
      <content type="html"><![CDATA[.koishi-block {
	width: 300px;
}]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>/about/about.js</url>
      <content type="html"><![CDATA[// $(function(){
// 	$(".fold-button").click(function(){
// 		$(".fold-box").slideToggle("slow");
// 		$(".open").toggle();
// 		$(".close").toggle();
// 	});
// });]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[about KoishiChan]]></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p><link rel="stylesheet" href="about.css"><br>KoishiChan不是很想写自我介绍，并且委屈地哭了起来.jpg<br><img src="QvQ.jpg" class="koishi-block"></p>
<h1 id="浙江大学·16级计科"><a href="#浙江大学·16级计科" class="headerlink" title="浙江大学·16级计科"></a>浙江大学·16级计科</h1><p>现浙江大学16级计算机系本科生之一。  </p>
<h1 id="github"><a href="#github" class="headerlink" title="github"></a>github</h1><p>除了作业以外的一大半代码都在<a href="https://github.com/xlnx" target="_blank" rel="external">github</a>上了，所以可能会显得比较杂乱<br>还算比较绿，看得过去  </p>
<h1 id="常用语言"><a href="#常用语言" class="headerlink" title="常用语言"></a>常用语言</h1><ul>
<li>C++</li>
<li>Python</li>
<li>Typescript</li>
<li><del>Object Pascal</del></li>
</ul>
<h1 id="pixiv"><a href="#pixiv" class="headerlink" title="pixiv"></a>pixiv</h1><p>咸鱼<a href="https://www.pixiv.net/member.php?id=10949667" target="_blank" rel="external">画手</a>，主要发表草稿和涂鸦级别的作品，<b>不过一直在坚持上色</b><br><del>有奇怪倾向的同人插画</del>  </p>
<h1 id="osu"><a href="#osu" class="headerlink" title="osu!"></a>osu!</h1><p>2017.4 - ????.?<br>咸鱼<a href="https://osu.ppy.sh/u/10004931" target="_blank" rel="external">osu玩家</a>，主要症状表现为  </p>
<ul>
<li>令人窒息的acc  </li>
<li>压倒性的retry次数  </li>
<li>pp虚高得很  </li>
</ul>
<h2 id="skin"><a href="#skin" class="headerlink" title="skin"></a>skin</h2><ul>
<li><a href="./skin/2017/11/6/Koishi~(Enhanced).osk">koishi~(Enhanced) 2017/11/6</a></li>
<li><a href="./skin/2017/11/22/Koishi~(Enhanced).osk">koishi~(Enhanced) 2017/11/22</a></li>
<li><a href="./skin/2018/1/3/Koishi~(Enhanced).osk">koishi~(Enhanced) 2018/1/3</a></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>现阶段咸鱼一条，正在努力变得不那么咸中…  </p>
<!-- <script type="text/javascript" src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"> -->
<script type="text/javascript" src="about.js">
</script>]]></content>
    </entry>
    
  
</search>
